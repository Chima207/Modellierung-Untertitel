0:00:00.000,0:00:06.240
After we
have dealt with

0:00:06.240,0:00:11.730
the types and characteristics of
models, it makes sense to

0:00:11.730,0:00:19.380
take a closer look at why
models are used in computer science.

0:00:19.380,0:00:21.960
So, why is there this
modeling lecture at all in the

0:00:21.960,0:00:27.120
context of computer science or
computer science-related courses of study?

0:00:27.120,0:00:32.100
And first of all, of course, the answer is
the same as further ahead, in an earlier video.

0:00:32.100,0:00:32.850

So:

0:00:32.850,0:00:38.250
You want to design a system, understand
it better, visualize it, simulate it, etc.

0:00:38.250,0:00:43.590
And the same can be relevant
for computer science systems, of course.

0:00:43.590,0:00:48.000
And especially the more complex a
computer science system is going to be.

0:00:48.660,0:00:51.420
A system could of course
be a program, a database, virtual

0:00:51.420,0:00:58.260
reality environments (i.e.
also quite representational systems).

0:00:58.260,0:01:02.190
And the more complex such a
system is, the more important it may

0:01:02.940,0:01:06.480
be to have a
plan before simply constructing it.

0:01:06.480,0:01:08.190
So, complexity plays a
role here, of course.

0:01:08.190,0:01:13.620
The same would be relevant
for other systems and models.

0:01:13.620,0:01:17.280
So depending on that,
when it comes to

0:01:17.280,0:01:21.150
architecture, it depends a lot on what
kind of house you're planning to build.

0:01:21.150,0:01:24.060
If you're just building a doghouse, you might
not need to have a plan and a

0:01:24.060,0:01:27.480
3D model for it, you can
just go ahead and do it.

0:01:27.480,0:01:34.050
If, on the other hand,
you're thinking of building a single-family

0:01:34.050,0:01:39.120
home or a larger apartment complex
or a high-rise building, that's definitely

0:01:39.120,0:01:42.150
complex enough to warrant
and also require a plan.

0:01:42.150,0:01:44.580
Similarly, of course,
for information technology systems.

0:01:44.580,0:01:48.510
So a small script that is written once,
certainly does not need to be modeled beforehand.

0:01:48.510,0:01:58.170
A more comprehensive program
or program system certainly does.

0:01:58.170,0:02:03.380
The goal and hope is
then of course that the

0:02:03.380,0:02:08.840
fact that one has modeled, before one
begins to implement, leads to various advantages:

0:02:08.840,0:02:10.520
Avoidance of
errors, better quality.

0:02:10.520,0:02:15.650
Lower costs because of
avoidance of repairs or wrong

0:02:15.650,0:02:24.320
ways, which one has to repeat then
or to replace detours by new development.

0:02:24.320,0:02:26.510
Better documentation
through models.

0:02:26.510,0:02:29.870
In the ideal case
also increase of the reusability.

0:02:29.870,0:02:34.040
This does not mean that modeling
is always used in computer science.

0:02:34.040,0:02:37.190
So there are
some special situations.

0:02:37.190,0:02:39.470
Agile software development
is very modern.

0:02:39.470,0:02:44.180
There, models are partly dispensed with, or at
least they appear in a different form, more as

0:02:44.180,0:02:49.100
part of the development than
as a separate planning process.

0:02:49.100,0:02:54.350
In general, it should be
noted that modeling is certainly less

0:02:54.350,0:02:57.890
common in computer science
than in other engineering sciences.

0:02:57.890,0:03:04.850
So in architecture or mechanical engineering,
modeling is definitely done before implementation.

0:03:04.850,0:03:06.830
In computer science, this
is not always the case.

0:03:06.830,0:03:11.810
But in principle, the topic is
of course just as relevant here.

0:03:11.810,0:03:16.910
It may also be that the prevalence
in teaching is still somewhat stronger than

0:03:16.910,0:03:21.650
in practice, but this does
not have to remain so.

0:03:26.900,0:03:30.305
Several peculiarities of software also influence
the role of computer science models.

0:03:30.305,0:03:36.740
For indeed, there are differences between
designing and building a computer science

0:03:36.740,0:03:41.090
system and, for example, designing and
building a building complex in architecture.

0:03:41.090,0:03:46.040
One major difference is
that software is immaterial.

0:03:46.040,0:03:51.020
It is not so easy to determine how
much of a model has already been implemented.

0:03:51.020,0:03:58.730
This is, of course, quite different in architecture, where, if
you build a skyscraper and have a model, you can

0:03:58.730,0:04:03.560
also determine on the basis of
this model, by comparing it with reality:

0:04:03.560,0:04:05.240
How much has
already been built?

0:04:05.240,0:04:07.190
How many floors
have already been built?

0:04:09.280,0:04:12.820
Another point is that
software projects are usually unique.

0:04:13.750,0:04:16.420
Whereas in architecture, for example,
and also in many other engineering

0:04:16.420,0:04:18.160
fields,
models also

0:04:18.160,0:04:23.410
have the role of serving as a
template for the purpose of multiple realizations.

0:04:23.410,0:04:28.870
In other words, a model is created in
order to be able to use the model as

0:04:30.520,0:04:34.360
a guide when large quantities of
an engine are to be produced.

0:04:34.360,0:04:37.753
In order to actually always build
the engine in the same way.

0:04:37.753,0:04:40.480
This is not the
case in software development.

0:04:40.480,0:04:44.320
Except perhaps in the context of
software product lines (which again would

0:04:44.320,0:04:49.330
be a topic for the software engineering lecture), it
is the case that each software project is unique.

0:04:49.330,0:04:54.430
So the model is not
there to be implemented multiple times.

0:04:54.430,0:04:59.410
Unlike in many other
areas, where, for example, in

0:04:59.410,0:05:03.940
architecture, 50 similar apartments are
to be created in a skyscraper.

0:05:03.940,0:05:08.650
Then the model, the plan, the 3D
plan is also good for ensuring that

0:05:08.650,0:05:13.030
the apartments on each floor actually
come out the same in the end.

0:05:13.030,0:05:16.960
This is not the
case in software technology.

0:05:16.960,0:05:20.890
So there are actually
differences to other areas.

0:05:20.890,0:05:25.930
And perhaps the second point is in
a way also a reason for reluctance to

0:05:25.930,0:05:30.340
always rely on models in
the practice of software development.

0:05:31.930,0:05:32.710
Then the
question also arises:

0:05:32.710,0:05:37.750
Who is it that models, in
computer science, in the software development process?

0:05:37.750,0:05:40.630
There the clear answer
is: it is unclear.

0:05:40.630,0:05:45.040
It depends on what kind of
software development process is being followed.

0:05:45.040,0:05:47.140
I just briefly
mentioned agile development.

0:05:47.140,0:05:49.570
There are also
classic software development processes.

0:05:49.570,0:05:54.640
If you are still
listening to Ms. Heisel's software

0:05:54.640,0:05:58.900
engineering lecture, you will certainly
learn more about this there.

0:05:58.900,0:06:02.170
For example, in the waterfall model,
which is structured by phases, where

0:06:02.170,0:06:05.260
you can very clearly
determine where modeling happens here.

0:06:05.260,0:06:07.360
This would be the
design phase in particular.

0:06:07.360,0:06:11.530
So modeling is then really
an act that takes place separately

0:06:11.530,0:06:16.510
from implementation, from programming, and
also justifies its own role.

0:06:16.510,0:06:21.670
So there might be the
programmer, the software developer, who implements.

0:06:21.670,0:06:25.540
And before that, there's the design
of the software architecture or just the

0:06:25.540,0:06:28.690
design, and that's a design task that
a programmer doesn't necessarily have to do.

0:06:28.690,0:06:32.110
So maybe that would also be
a role for Komedia graduates, for example.

0:06:32.110,0:06:36.940
And models are
now explicitly popping up.

0:06:36.940,0:06:39.700
So at different levels,
models are created, and

0:06:39.700,0:06:43.990
then there are really, for example, concrete
documents that you can also look at.

0:06:43.990,0:06:49.780
That would be the models in
such a procedure, maybe on different levels.

0:06:49.780,0:06:53.530
The result of the determination
of the requirements could be this

0:06:53.530,0:06:56.140
product requirements document, which
is a kind of model.

0:06:56.140,0:07:00.850
And then, during design, models are
created that are to be implemented later

0:07:00.850,0:07:04.420
and can be used for
comparison in later phases, for example.

0:07:04.420,0:07:09.250
Verification could then be to compare the
implementation against the model and to formally

0:07:09.250,0:07:15.160
ensure, by testing or by
proof, that there is a match.

0:07:15.160,0:07:19.630
This will not be a
topic of the lecture in particular.

0:07:19.630,0:07:24.010
So we will mainly deal with
the formulation of the models and

0:07:24.010,0:07:27.640
statements, not
with the verification/testing.

0:07:30.820,0:07:34.900
That was just a
concrete model, a concrete process.

0:07:34.900,0:07:40.150
There are various other
ways to do software development.

0:07:40.720,0:07:48.880
Another way is iterative, so where the
phases are not done once in a waterfall

0:07:48.880,0:07:51.910
fashion, but multiple phases are
done over and over again for

0:07:51.910,0:07:59.260
different prototypes, for different implementations
of the system being built.

0:07:59.260,0:08:04.450
And in each of these spirals in
this execution, modeling could also take place.

0:08:04.450,0:08:08.410
Because in each case
new aspects are brought into

0:08:08.410,0:08:12.670
play, for example the models
are refined to define more precise

0:08:12.670,0:08:18.100
requirements or additional requirements
for the next implementation cycle.

0:08:19.210,0:08:20.740
Of course, what you see
here are also just models.

0:08:20.740,0:08:23.890
So no one perhaps is
going to proceed exactly like this.

0:08:23.890,0:08:28.900
What we see and have seen
are ultimately also models, so-called process models,

0:08:28.900,0:08:33.160
which abstract precisely from how
a concrete software development could happen.

0:08:33.160,0:08:43.870
And this does not capture
every detail of every possible software

0:08:43.870,0:08:48.220
development procedure or every concrete project that
might be carried out in a team.

0:08:48.220,0:08:53.620
But it does provide a
model for it, a simplified representation

0:08:53.620,0:08:54.940
that can be
used as a guide.

0:08:54.940,0:08:58.840
We will not consider
such models further, because process

0:08:58.840,0:09:04.000
models are also part of the
software engineering lecture with Mrs. Heisel.

0:09:04.000,0:09:09.100
I had already
mentioned special cases.

0:09:09.100,0:09:15.520
So in agile software development, modeling
is different, one could also say less.

0:09:15.520,0:09:20.080
Strictly speaking, models also appear
there, but rather in later phases.

0:09:20.080,0:09:21.250
The models
are rather short-lived.

0:09:21.250,0:09:25.570
They are used for test-driven
(instead of plan-driven) development, for example.

0:09:27.130,0:09:33.430
Other special cases would
be in open source software

0:09:33.430,0:09:39.100
development, where there are often many
different contributors working on a project.

0:09:39.100,0:09:42.640
Where somehow centralized modeling
could not be used at

0:09:42.640,0:09:47.140
all, but completely different
effects come into play.

0:09:47.140,0:09:51.692
On the other hand, there are also
development methods that are very strongly model-driven.

0:09:51.692,0:09:54.760
There is even the
term model-driven development, where

0:09:54.760,0:10:01.060
actually program code/software is to
be generated from the models.

0:10:01.060,0:10:04.360
So there are
different varieties, different manifestations.

0:10:04.360,0:10:08.830
As I said, this would be
a topic for the software engineering lecture.

0:10:08.830,0:10:09.730
What is relevant
for us is:

0:10:09.730,0:10:13.300
There is the need for models
in different phases in software development.

0:10:13.300,0:10:20.230
And that's why this lecture will
just focus on these types of models.

0:10:22.960,0:10:28.420
Other important aspects when working with
models are of course questions like:

0:10:28.420,0:10:30.130
Is the model
correct at all?

0:10:30.130,0:10:31.540
Is it
consistent in itself?

0:10:31.540,0:10:36.040
Model correctness is of course difficult to
answer if you set up the model in

0:10:36.040,0:10:41.680
the first place in order to be aware of
what the system that is being developed should look like.

0:10:41.680,0:10:46.390
Then you don't really have a handle
on how to check it for correctness.

0:10:46.390,0:10:48.940
But for example, internal
consistency could be checked.

0:10:48.940,0:10:50.800
That should also come
up in our example.

0:10:50.800,0:10:59.950
So correctness objectively would mean to check
somehow whether the system fulfills the purpose.

0:10:59.950,0:11:03.250
And that must depend on the
purpose, and is not necessarily clear

0:11:03.250,0:11:06.010
when the system
is still being designed.

0:11:06.010,0:11:09.100
Internal correctness, on the other
hand, is quite testable or verifiable.

0:11:10.600,0:11:12.670
We will have, for instance,
in the model type of

0:11:12.670,0:11:14.920
Petri nets, certain properties that
a Petri net can have.

0:11:14.920,0:11:17.890
This then corresponds to
a certain absence of contradictions.

0:11:17.890,0:11:21.310
Liveness is also such a
concept, which is always meaningful.

0:11:22.330,0:11:25.900
One can also formulate a
problem for the model class itself.

0:11:25.900,0:11:27.250
For example, one
can determine general properties

0:11:27.250,0:11:29.260
for Petri nets,
which one can check.

0:11:29.260,0:11:35.200
And if you now have
or set up a concrete

0:11:35.200,0:11:37.210
model, then you can check
whether it has such a property.

0:11:37.210,0:11:42.499
And this is independent of the
concrete purpose of the system in question.

0:11:42.499,0:11:45.400
That's why we
can perform certain

0:11:46.060,0:11:49.900
analyses on models that are useful
for a whole class of models.

0:11:49.900,0:11:51.700
This will not be in the
foreground, will not be the main part

0:11:51.700,0:11:56.230
of the lecture, but
it will come up.

0:11:56.230,0:11:58.960
And of
course in a

0:11:58.960,0:12:04.750
different context, when you really build the system
in the end, then you can of course ask:

0:12:04.750,0:12:08.980
Does the model
match the later implementation?

0:12:08.980,0:12:10.705
That, too, will not be
so relevant for us here.

0:12:10.705,0:12:13.090
You would have to
test or verify it.

0:12:13.090,0:12:16.900
That is not
our main focus.

0:12:16.900,0:12:22.600
For some of these questions,
tools or software tools are used.

0:12:23.230,0:12:25.330
Be it for drawing,
for representing models, or

0:12:25.330,0:12:28.270
for switching between different
representations of a model.

0:12:28.270,0:12:32.200
For archiving, for code generation,
documentation, and of course for analysis.

0:12:32.200,0:12:38.140
Again, this will not take up
a lot of space in the lecture.

0:12:38.140,0:12:41.380
A few tools for use
in the lecture, especially for

0:12:41.380,0:12:46.960
the representation and partly also the simulation
of single models (especially for Petri nets),

0:12:46.960,0:12:52.330
can already be found as
suggestions in the Moodle course.

0:12:52.330,0:12:56.560
In the lecture itself this will occur
at most times, when I want to work

0:12:56.560,0:13:03.040
with Petri nets, and then perhaps also in
video form times a simulation will carry out.

0:13:08.380,0:13:14.050
From this it is now a bit clearer
what will make up the content of the course.

0:13:14.050,0:13:15.040
So here's
a brief overview.

0:13:15.040,0:13:16.390
It's not exactly
in that order.

0:13:16.390,0:13:19.480
So it's not chapters
that I'm going to follow.

0:13:19.480,0:13:23.290
However, the essential
things are mentioned here.

0:13:23.290,0:13:26.800
So we're going to need some
mathematical basics, of course, and develop

0:13:26.800,0:13:33.610
some of them, or I'll give you,
without it being a first chapter right now.

0:13:33.610,0:13:37.750
One important type of description, which of
course has a mathematical basis, is graphs.

0:13:41.140,0:13:42.400
We have
visual representation

0:13:43.180,0:13:46.480
models, and usually these will
be different kinds of graphs.

0:13:46.480,0:13:50.590
This can be relevant for
both static and dynamic system descriptions.

0:13:50.590,0:13:55.450
So a graph to describe the
relationships between subcomponents of a system would

0:13:55.450,0:13:57.130
then be relevant
for static modeling.

0:13:57.130,0:14:02.200
Or for dynamic modeling, that
a graph represents, for example, flows,

0:14:02.200,0:14:06.190
represents processes
in their order.

0:14:06.190,0:14:10.300
Graphs, of course,
are a general concept.

0:14:10.300,0:14:12.220
And then beyond that,
there are Petri nets.

0:14:12.220,0:14:13.030
These are
also graphs.

0:14:13.030,0:14:18.190
I had mentioned Petri
nets briefly for dynamic modeling.

0:14:18.190,0:14:20.530
So that will be
a chapter in the lecture.

0:14:22.180,0:14:28.255
You may already have some
insight there from the pre-course.

0:14:28.255,0:14:31.180
I know that Petri nets are
sometimes treated there as an example.

0:14:31.180,0:14:33.580
Probably not in
school computer science.

0:14:34.420,0:14:36.520
Petri nets will also be
interesting for us because, on

0:14:36.520,0:14:40.870
the one hand, they are well
suited to teach certain concepts of distributed

0:14:40.870,0:14:47.620
systems such as concurrency,
conflicts, liveness, and so on.

0:14:47.620,0:14:51.310
On the other hand, Petri nets
are also quite a formal modeling tool.

0:14:51.310,0:14:56.035
That is, you should also see
how to deal with models formally.

0:14:56.035,0:14:57.790
Petri nets are very
well suited for that.

0:14:57.790,0:15:04.630
There is also a bridge from Petri
nets to UML, to a subset of UML.

0:15:04.630,0:15:05.800
And there you
will also see how

0:15:05.800,0:15:10.810
you can establish connections
between different modeling mechanisms.

0:15:10.810,0:15:16.120
How, for example, you can
systematically generate Petri nets from a

0:15:16.120,0:15:20.110
certain class of UML diagrams, and
then analyze them formally, for example.

0:15:20.110,0:15:25.480
UML itself might be known from
school, possibly also from the computer

0:15:25.480,0:15:27.130
science pre-course, at
least in excerpts.

0:15:27.130,0:15:28.930
So at
least class diagrams.

0:15:28.930,0:15:31.810
If you have covered object-oriented programming
in school in computer science classes,

0:15:32.650,0:15:37.720
then you have probably already
worked with UML at least indirectly.

0:15:37.720,0:15:44.020
Both Petri nets and UML you
may encounter further in your studies.

0:15:44.020,0:15:47.080
Of course, this depends specifically
on your course of study.

0:15:47.080,0:15:53.410
Petri nets are relevant in the context of
distributed systems and will certainly come up again.

0:15:53.410,0:15:59.320
UML used to be a
prominent part of the lecture Basic

0:15:59.320,0:16:01.390
Programming Techniques, because
Java was used.

0:16:01.390,0:16:06.040
Now, after the switch to Python,
it is probably at most on

0:16:06.040,0:16:08.710
the margins, if some Java is still
done in the end in the course.

0:16:08.710,0:16:11.290
On the other hand, UML will certainly
feature very prominently in the Advanced Programming

0:16:11.290,0:16:18.670
Techniques and Software
Engineering lectures as well.

0:16:18.670,0:16:22.000
Of course, it is the
case that we will mainly

0:16:22.000,0:16:27.400
deal with small models in
the course (for clarity/didactics of teaching).

0:16:28.810,0:16:30.040
Said
also:

0:16:30.040,0:16:34.750
The use of models for the verification of
properties will not be in the center, but

0:16:34.750,0:16:37.900
will at least appear
once in Petri nets.

0:16:41.050,0:16:44.290
We will of course
do static and dynamic

0:16:44.290,0:16:45.760
modeling, especially in
the context of UML.

0:16:45.760,0:16:49.090
Both are not
very formal there.

0:16:49.090,0:16:50.695
With Petri
nets more formal.

0:16:50.695,0:16:52.450
UML, I had already said
in the last video, is

0:16:52.450,0:16:57.580
rather a
semi-formal modeling method.

0:16:57.580,0:17:07.360
Of course, even that, with this
scope, is by no means somehow comprehensively

0:17:07.360,0:17:09.370
everything you can do in
computer science in terms of models.

0:17:09.370,0:17:12.490
The course is
just an excerpt.

0:17:12.490,0:17:16.150
The modeling methods presented here
are not the only ones available.

0:17:16.150,0:17:21.100
The focus here is
on visual modeling using diagrams.

0:17:21.100,0:17:25.000
I had already mentioned that there
is of course also mathematical modeling, algebraic

0:17:25.000,0:17:30.850
modeling methods that are more
oriented to mathematical formula language.

0:17:30.850,0:17:31.660
We're going to
do less of that.

0:17:31.660,0:17:35.050
A little bit in
describing operations, but by

0:17:35.050,0:17:41.110
no means to the extent that you could
also do that in a lecture like this.

0:17:45.040,0:17:48.370
At the end of this
video, a short word cloud.

0:17:48.370,0:17:53.080
It gives a good overview
of the content of the course.

0:17:53.080,0:17:59.710
These are simply several terms that were
collected in the slides of a previous

0:17:59.710,0:18:03.235
year in their frequency
and then visualized here.

0:18:03.235,0:18:05.590
So here you see
some very prominent terms.

0:18:05.590,0:18:06.880
Of
course:

0:18:06.880,0:18:09.040
"model," "modeling," "diagram" would
also show up here.

0:18:09.040,0:18:10.270
But I have
taken them out.

0:18:10.270,0:18:11.350
They would have
been too dominant,

0:18:11.350,0:18:17.590
because just because of this term down
here, it shows up almost on every slide.

0:18:17.590,0:18:19.210
I had
therefore removed them.

0:18:19.900,0:18:25.570
Otherwise, if you then dive
into these terms, you will see

0:18:25.570,0:18:27.100
that certain things
are very prominent there.

0:18:27.100,0:18:32.650
Of course, the descriptive terms "Petri
net" and "UML" show up prominently.

0:18:32.650,0:18:35.140
You can see that we will
obviously be working a lot with examples.

0:18:35.140,0:18:38.560
That's why the word "example" shows
up very often in the slides here.

0:18:38.560,0:18:42.850
Then there are more concrete terms like
"object" because we will be doing object-oriented

0:18:42.850,0:18:45.520
modeling to
some extent.

0:18:45.520,0:18:46.169

"State."

0:18:46.169,0:18:50.060
That's obviously about static
modeling, the description of a

0:18:50.060,0:18:54.260
state, or dynamic modeling, the evolution
of the state of a system.

0:18:54.260,0:18:55.040

"Transition":

0:18:55.040,0:18:58.070
A term
from dynamic modeling.

0:18:58.070,0:18:59.450

"Transition":

0:18:59.450,0:19:01.940
As a
synonym for it.

0:19:01.940,0:19:07.040
In graphs, "nodes" appear,
as parts of a graph.

0:19:07.040,0:19:10.130
And then more
specific terms like "region".

0:19:10.130,0:19:14.990
This is a concept that
appears in certain UML diagram types.

0:19:14.990,0:19:18.020
Activity diagrams is what
we're going to cover.

0:19:18.020,0:19:22.940
So you can get a little
bit of an initial sense here of

0:19:22.940,0:19:24.215
what we're going
to be dealing with.

0:19:24.215,0:19:26.480
There are also terms that come
up that are not really relevant anymore:

0:19:26.480,0:19:29.900
Substitution I probably
won't look at explicitly.

0:19:29.900,0:19:33.080
That was also in
the context of object-oriented modeling.

0:19:33.080,0:19:38.600
The substitution principle, I'm not
going to focus on that anymore.

0:19:38.600,0:19:46.340
So again, you can't derive too
much from the word cloud either.

0:19:46.340,0:19:54.500
But a little bit of an impression
of what you can expect already emerges here.
