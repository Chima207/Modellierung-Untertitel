0:00:00.000,0:00:07.410
Nachdem wir uns im letzten Video
mit Graphen beschäftigt haben,

0:00:07.410,0:00:15.870
und das anhand dieses kleinen Rätsels getan
haben, wird es in diesem Video einerseits um

0:00:15.870,0:00:23.880
etwas sehr viel informatikspezifischeres gehen und
andererseits wird es auch nicht um Graphen gehen.

0:00:23.880,0:00:28.380
Ich hatte gesagt, dass wir sehr viel mit
Graphen modellieren werden, aber wir brauchen

0:00:28.380,0:00:34.620
tatsächlich (insbesondere als Vorbereitung für
UML) noch eine weitere Zutat, die textuell ist.

0:00:34.620,0:00:36.750
Nämlich das statische Modellieren von Operationen.

0:00:37.800,0:00:40.890
Und darum soll es in diesem Video gehen.

0:00:40.890,0:00:47.430
Weil das eine Voraussetzung und Vorbereitung
ist für den objektorientierten Klassenentwurf,

0:00:47.430,0:00:52.620
bzw. die Modellierung von Klassen
und insbesondere ihren Methoden.

0:00:52.620,0:00:54.210
Aber dazu werden wir dann kommen.

0:00:54.210,0:00:58.500
Zunächst noch recht allgemein
und auch von UML losgelöst.

0:00:58.500,0:01:01.140
Tatsächlich spielen Operationen natürlich sowohl

0:01:01.140,0:01:04.770
in der Mathematik eine Rolle, als auch der
Informatik unabhängig von Objektorientierung.

0:01:05.520,0:01:10.650
Worum geht es da jetzt spezifisch,
auch im Informatikkontext?

0:01:10.650,0:01:13.050
Angenommen wir wollen ein System
in der Informatik entwerfen,

0:01:13.050,0:01:15.450
sei es ein Programm, sei es eine Datenbank.

0:01:15.450,0:01:17.850
Dann stellt sich oft zunächst mal die Frage,

0:01:17.850,0:01:20.460
welche Operationen denn angeboten
und umgesetzt werden sollen.

0:01:20.460,0:01:24.810
Und mindestens genauso wichtig, neben
einfach den Namen von Operationen,

0:01:24.810,0:01:28.080
auch auf was für Daten sie arbeiten sollen.

0:01:28.080,0:01:31.950
Da geht es um statische Modellierung.

0:01:31.950,0:01:33.480
Es geht letztlich um den Aufbau des Systems

0:01:33.480,0:01:36.750
oder von dem System angebotene
Funktionalitäten und Services.

0:01:36.750,0:01:42.150
Also geht es nicht darum, was
die Operationen genau tun werden,

0:01:42.150,0:01:46.470
sondern erst mal zum Beispiel welche Aufrufe /
Verwendungen syntaktisch erlaubt sein sollen.

0:01:46.470,0:01:50.700
Was überhaupt sinnvolle
Operationsverwendungen sein sollen,

0:01:50.700,0:01:53.670
und auch, wie Operationen
kombiniert werden können.

0:01:53.670,0:01:56.250
In der Regel wird ein System aus
vielen Funktionalitäten bestehen,

0:01:56.250,0:02:01.110
die gegebenenfalls in Kombination
benutzt werden müssen.

0:02:03.060,0:02:05.220
Und mindestens wäre das
wichtig für die Dokumentation.

0:02:06.090,0:02:13.950
Also wir können einfach durch Festhalten
dieser statischen Informationen etwas

0:02:13.950,0:02:17.190
über das System erfahren, auch ohne uns
die Implementierung anschauen zu müssen.

0:02:17.190,0:02:21.390
Und im Idealfall hilft es dann
auch bei der Implementierung,

0:02:22.200,0:02:27.780
etwa indem präzise erfasst ist, welche Fälle
von Eingaben überhaupt behandelt werden müssen.

0:02:27.780,0:02:33.540
Oder indem per Konsistenzprüfung möglicherweise
bestimmte Fehler vermieden werden können,

0:02:33.540,0:02:36.720
schon bevor man testet oder
irgendetwas zu beweisen versucht.

0:02:36.720,0:02:40.110
Einfach dadurch, dass man vorher festgehalten hat,

0:02:40.110,0:02:43.950
wie die Operationen heißen (die Namen
sind auch wichtig), aber eben auch, auf

0:02:43.950,0:02:50.010
welchen Arten von Daten sie operieren und welche
Kombinationen von Operationen erlaubt sein sollen.

0:02:51.630,0:02:55.440
Dann können beim Programmieren, beim
Implementieren, Fehler aufgedeckt werden,

0:02:55.440,0:02:59.130
die sonst vielleicht erst im Betrieb
auffallen würden oder wenn man das

0:02:59.130,0:03:00.870
System implementiert hat und testen möchte.

0:03:03.240,0:03:04.890
Ich erkläre zunächst an einem ganz

0:03:04.890,0:03:07.140
einfachen Beispiel, sozusagen
an einer ganz einfachen Domäne.

0:03:07.800,0:03:10.680
Operationen beziehen sich immer auf
irgendeinen speziellen Anwendungsbereich.

0:03:10.680,0:03:12.930
Und der Anwendungsbereich,
den Sie aus der Schule kennen,

0:03:12.930,0:03:16.650
wo Ihnen Operationen begegnet
sind, ist einfach Arithmetik.

0:03:16.650,0:03:20.250
Also die arithmetischen Operationen, die
heißen ja so: "Plus", "Minus", "Mal", etc.

0:03:20.250,0:03:22.350
Das sind natürlich Operationen in diesem Sinne.

0:03:22.350,0:03:25.530
Und je nachdem, womit wir
dann in einem System arbeiten,

0:03:25.530,0:03:28.050
haben wir natürlich noch mit
mehr zu tun als nur mit Zahlen.

0:03:28.050,0:03:29.790
Aber Zahlen werden wahrscheinlich auch immer

0:03:29.790,0:03:32.250
irgendwie in irgendeiner Form
in einem Programm im Spiel sein.

0:03:32.250,0:03:34.620
Also stellen wir uns vor, ganz naiv:

0:03:34.620,0:03:37.290
Wir wollen vielleicht eine
Taschenrechner-App entwerfen.

0:03:37.290,0:03:42.450
Dann sind die relevanten Operationen,
die wir wahrscheinlich anbieten wollen,

0:03:42.450,0:03:45.030
mindestens die üblichen
arithmetischen Operationen.

0:03:45.030,0:03:46.830
Und vielleicht haben wir uns entschieden,

0:03:46.830,0:03:50.325
dass wir die Menge der natürlichen
Zahlen nehmen wollen, inklusive der Null.

0:03:50.325,0:03:54.900
Also wir rechnen erst mal nicht mit
gebrochenen Zahlen, mit Fließkommazahlen.

0:03:54.900,0:03:57.210
Dann könnten wir sagen:

0:03:57.210,0:04:01.710
Gut, dann ist die Addition eine binäre
Operation (weil sie zwei Argumente nimmt,

0:04:01.710,0:04:07.110
nämlich zweimal jeweils eine natürliche Zahl)
und liefert eine natürliche Zahl zurück.

0:04:07.110,0:04:08.340
Das ist Mengennotation: eine Funktion.

0:04:08.340,0:04:14.300
Eine Funktion, angegeben mit ihrem
Wertebereich und ihrem Bildbereich.

0:04:14.300,0:04:19.070
Die Komedia-Studierenden sollten das als Notation

0:04:19.070,0:04:22.970
aus der Mathematikvorlesung aus
dem zweiten Semester kennen.

0:04:22.970,0:04:24.530
Die Informatik-Studierenden und
die ISE-Studierenden aus ihren

0:04:24.530,0:04:28.010
jeweiligen Lehrveranstaltungen, in
denen Mengenlehre betrieben wird.

0:04:28.010,0:04:30.290
Wahrscheinlich zum Beispiel
die Diskrete Mathematik bei

0:04:30.290,0:04:32.060
den Angewandte-Informatik-Studierenden.

0:04:32.060,0:04:38.090
Ich gehe davon aus, dass das da bereits
sehr früh im Semester als Notation vorkommt.

0:04:38.090,0:04:44.210
Ansonsten in diesem Moment einfach ein
Operationsname "Plus", zwei Argumente,

0:04:44.210,0:04:45.980
jeweils natürliche Zahlen
(N für natürliche Zahlen).

0:04:45.980,0:04:47.750
Ergebnis auch eine natürliche Zahl.

0:04:47.750,0:04:49.040
Und natürlich:

0:04:49.040,0:04:52.220
Wenn wir mehrere Operationen
haben (man will etwa auch die

0:04:52.220,0:04:55.310
Multiplikation haben), dann haben die einen
anderen Namen (aber hier den gleichen Typ,

0:04:55.310,0:04:57.290
die gleiche Information
über Ein- und Ausgabewerte).

0:05:00.020,0:05:04.340
Und, sagen wir mal, vielleicht noch die Division.

0:05:04.910,0:05:08.978
Subtraktion könnte man sich auch vorstellen,
aber schon bei Division stellt sich die Frage:

0:05:08.978,0:05:14.090
Von welcher Art soll denn hier
überhaupt der Ausgabewert sein?

0:05:14.090,0:05:17.150
Und wir könnten sagen:

0:05:17.150,0:05:18.470
Gut, wir wissen was Division ist.

0:05:18.470,0:05:20.510
Aber genau genommen sind dies
hier im Moment erst mal nur

0:05:20.510,0:05:24.470
Angaben zu den Parametern und den Ergebnissen.

0:05:24.470,0:05:27.050
Also hier auch, wenn wir
"Plus" als Addition kennen,

0:05:27.050,0:05:29.600
ist hier noch nicht festgehalten,
was Operationen tatsächlich tun.

0:05:29.600,0:05:35.960
Im Moment versuchen wir, uns darüber klar zu
werden, was ihre Ein- und Ausgabebereiche sind.

0:05:35.960,0:05:40.670
Und wahrscheinlich würde man hier zum
Beispiel wollen, dass man zumindest

0:05:40.670,0:05:44.660
Division durch Null verbietet, damit das eben
nicht aufgerufen werden kann mit fünf und null.

0:05:44.660,0:05:45.530
Weil hier oben steht:

0:05:45.530,0:05:48.110
N sei die Menge der natürlichen
Zahlen inklusive der Null.

0:05:48.110,0:05:54.920
Also könnte man sich hier entscheiden, zu sagen,
man möge zunächst erst mal (bevor man sich

0:05:54.920,0:06:00.230
entscheidet, was der Ausgabebereich sein wird)
den zweiten Eingangsbereich etwas verfeinern.

0:06:00.230,0:06:02.660
Etwas einschränken, indem man sagt:

0:06:02.660,0:06:08.630
Wir nehmen da die Menge N+ als Notation
für nur positive natürliche Zahlen.

0:06:08.630,0:06:12.830
Dann würde man zum Beispiel die
Operation statisch so definieren,

0:06:12.830,0:06:15.410
um einfach zu verbieten, dass das
zweite Argument null sein darf.

0:06:15.410,0:06:20.300
Dann kann man das natürlich in
weniger Situationen verwenden.

0:06:20.300,0:06:24.200
Man kann das immer noch für
natürliche Zahlen verwenden,

0:06:24.200,0:06:27.740
die positiv sind, aber eben nicht mehr
für die Null selber als zweites Argument.

0:06:27.740,0:06:30.290
In der ersten Position dürfte man
nach wie vor noch die Null haben.

0:06:30.290,0:06:31.940
Also null durch fünf würde weiter gehen.

0:06:33.620,0:06:38.060
Dann müsste man sich irgendwie auch
Gedanken über den Ausgabebereich machen.

0:06:38.060,0:06:38.990
Vor allem:

0:06:38.990,0:06:39.740
Was möchte man hier?

0:06:39.740,0:06:43.880
Also wenn man fünf und drei als Argumente
hat (was ja jeweils passen würde,

0:06:43.880,0:06:47.990
weil drei eine positive natürliche Zahl
ist), was soll dann das Ergebnis sein?

0:06:47.990,0:06:52.670
Soll das 1,666 sein, oder
vielleicht einfach nur 1 abgerundet?

0:06:52.670,0:06:57.380
Macht man ganzzahlige Division, oder
möchte man rationale Zahlen unterstützen?

0:06:57.380,0:07:00.950
Das ist genau die Entscheidung, die man
jetzt trifft beim Entwurf dieser Operation.

0:07:00.950,0:07:04.160
Wo man sich dafür entscheidet,
welchen Bereich man hier will.

0:07:04.160,0:07:06.530
Das wäre die Entscheidung zwischen:

0:07:06.530,0:07:09.200
Ich erlaube hier nur natürliche Zahlen.

0:07:09.200,0:07:14.720
Dann muss ich auch die Null erlauben wegen 0
/ 5 = 0, und bei fünf durch drei würde ich 1

0:07:14.720,0:07:17.690
zurückgeben wollen (also ganzzahlig
dividieren und den Rest verwerfen).

0:07:17.690,0:07:19.760
Oder möchte ich rationale Zahlen unterstützen?

0:07:19.760,0:07:22.400
Dann müsste ich schon hier beim statischen Entwurf

0:07:22.400,0:07:25.850
der Operation vorsehen, dass dort
auch rationale Zahlen stehen dürfen.

0:07:25.850,0:07:28.010
Die natürlich die natürlichen Zahlen enthalten,

0:07:28.010,0:07:31.970
aber eben auch noch weitere Kandidaten
als Ausgaben zur Verfügung stellen.

0:07:31.970,0:07:34.520
Und vielleicht würde man sogar beides wollen.

0:07:34.520,0:07:36.665
Also die Mathematiker machen das natürlich gern.

0:07:36.665,0:07:40.460
Die verwenden immer das gleiche
Symbol, in gewissem Sinne überladen,

0:07:40.460,0:07:43.100
sodass es zum Beispiel vom Kontext abhängen kann,

0:07:43.100,0:07:47.750
welche Ausprägung genau gewünscht ist (die
ganzzahlige oder die nicht ganzzahlige).

0:07:49.940,0:07:51.710
Und es gibt natürlich auch kein
wirkliches "richtig" oder "falsch",

0:07:51.710,0:07:52.910
keine richtige oder falsche Entscheidung.

0:07:52.910,0:07:54.020
Es hängt vom Anwendungszweck ab.

0:07:54.020,0:07:56.030
Also Sie können nicht sagen:

0:07:56.030,0:07:59.120
Das hier ist die richtige Wahl
und das hier ist die falsche Wahl.

0:07:59.120,0:08:00.080
Das wäre Unsinn.

0:08:00.080,0:08:04.550
Letztlich ist es gerade Teil des
Modellierens, herauszuarbeiten:

0:08:04.550,0:08:08.270
Was ist denn eigentlich im
aktuellen Anwendungskontext

0:08:08.270,0:08:16.610
der gewünschte Bereich, der hier stehen soll?

0:08:16.610,0:08:20.870
Bis hin dazu, vielleicht beides zu unterstützen
und dann im System geeignete Mechanismen

0:08:20.870,0:08:27.575
vorzusehen, dass das jeweils abhängig von der
aktuellen Situation entschieden werden kann.

0:08:27.575,0:08:29.960
Oder zumindest müsste man festhalten,
welche Varianten es denn gibt.

0:08:32.370,0:08:35.880
Aufzupassen ist natürlich auch, dass man, wenn
man zum Beispiel die rationalen Zahlen nimmt,

0:08:35.880,0:08:37.980
plötzlich sehr viel mehr ins Spiel gebracht hat.

0:08:37.980,0:08:41.910
Nicht nur die rationalen Zahlen, also die
gebrochenen Zahlen, sondern auch negative Zahlen.

0:08:41.910,0:08:45.660
Denn die natürlichen Zahlen, ob nun mit oder
ohne null, waren zumindest nicht negativ.

0:08:45.660,0:08:50.250
Wenn ich mich hier für die rationalen Zahlen
entscheide, müsste ich auch damit umgehen,

0:08:50.250,0:08:54.900
dass ich dann negative Zahlen dabei hätte
(wenn ich mich hier nicht auf die nur

0:08:54.900,0:08:57.600
positiven und nicht-negativen
rationalen Zahlen beschränke).

0:08:57.600,0:09:00.090
Also dies ist die Entscheidung,
die man an diesen Stellen trifft.

0:09:02.910,0:09:07.500
Und natürlich, sobald ich das getan habe, also
sobald ich statt N auch N+ oder Q eingeführt habe,

0:09:07.500,0:09:10.350
stellt sich auch die Frage, was denn
mit den anderen Operationen ist.

0:09:10.350,0:09:14.970
Also "Plus" etc., was vorher nur für
die natürlichen Zahlen im Spiel war.

0:09:14.970,0:09:19.020
Sobald ich jetzt zum Beispiel
diese extra Menge eingeführt habe,

0:09:19.020,0:09:23.670
um mit der Division durch null umgehen zu
können (durch Verbieten), fragt man sich auch:

0:09:23.670,0:09:28.560
Was ist denn mit der vorher schon
existierenden Operation "Plus"?

0:09:28.560,0:09:31.230
Verhält diese sich vielleicht auch
irgendwie anders, wenn einer der

0:09:31.230,0:09:34.050
beiden Argumentbereiche durch N+ ersetzt wird?

0:09:34.050,0:09:36.870
Also würde man sich dann als nächstes fragen:

0:09:36.870,0:09:44.520
Was wäre denn jetzt, wo wir mehrere
verschiedene Mengenbereiche im Spiel haben?

0:09:44.520,0:09:48.960
Was bedeutet das denn für die statischen
Informationen zu den anderen Operationen?

0:09:48.960,0:09:52.320
Kann man die vielleicht auch präzisieren, oder
muss man da irgendwelche Änderungen vornehmen?

0:09:53.250,0:09:55.470
In der Tat, in dem konkreten
Fall kann man die präzisieren.

0:09:55.470,0:09:55.890
Man weiß nämlich:

0:09:55.890,0:10:01.140
Wenn man die Addition hat und mindestens
einer der beiden Summanden ist positiv,

0:10:01.140,0:10:02.430
dann ist das Ergebnis auch positiv.

0:10:02.430,0:10:04.770
Vorher stand hier: N und N geht nach N.

0:10:04.770,0:10:07.440
Jetzt können wir zusätzlich festhalten:

0:10:07.440,0:10:15.060
Wenn einer der beiden Parameter, zum Beispiel
der erste, eine mit Sicherheit positive Zahl ist,

0:10:15.060,0:10:17.340
dann wäre nach der Addition
auch das Ergebnis positiv.

0:10:17.340,0:10:18.780
Das ist dann mehr Information.

0:10:18.780,0:10:23.400
Also statisch wissen wir dann mehr über das
Ergebnis als vorher, wo hier nur N stand.

0:10:23.400,0:10:26.040
Das hätte auch erlaubt,
dass dort null herauskommt.

0:10:26.850,0:10:30.540
Das wird nicht passieren, wenn mindestens eins
der beiden Argumente gesichert nicht null ist.

0:10:32.220,0:10:36.360
Natürlich ginge das genauso für
die andere Position festzuhalten.

0:10:36.360,0:10:39.960
Und man könnte auch festhalten, für
die Multiplikation zum Beispiel,

0:10:39.960,0:10:43.860
dass wenn beide Argumente positiv
sind, auch das Ergebnis positiv ist.

0:10:44.490,0:10:50.760
Hingegen natürlich nicht etwa diese
Information, denn die wäre falsch.

0:10:50.760,0:10:57.660
Es stimmt nicht, dass eine positive Zahl mal eine
natürliche Zahl immer eine positive Zahl ist.

0:10:57.660,0:11:01.740
Also hier ergibt sich wirklich
Unterscheidungspotenzial zwischen

0:11:01.740,0:11:05.400
den Operationen, das man an dieser
Operation festhalten kann und sollte.

0:11:06.390,0:11:09.510
Dann haben wir zwar nicht ganz genau
definiert, was Multiplikation genau tut.

0:11:09.510,0:11:15.090
Aber diese Einschränkung, dass anders als bei
der Addition nicht einfach schon die Tatsache,

0:11:15.090,0:11:19.680
dass eins der Argumente positiv ist, dafür
reicht, dass auch das Ergebnis positiv ist,

0:11:19.680,0:11:27.540
das kann man hier bereits als Unterscheidung
zwischen diesen beiden Operation festhalten.

0:11:27.540,0:11:28.680
Wozu das Ganze?

0:11:28.680,0:11:31.500
Weil wir dann anhand von
dieser statischen Information,

0:11:31.500,0:11:35.730
also ohne eine Implementierung der Operation
zu haben (ohne wirklich etwas auszurechnen),

0:11:35.730,0:11:40.860
bereits feststellen können, ob etwa
gewisse Ausdrücke, gewisse Terme,

0:11:40.860,0:11:45.330
gewisse Formeln, die man hinschreiben
kann, okay sind oder nicht okay sind.

0:11:45.330,0:11:49.230
Wir haben hier zwei Formeln stehen,

0:11:49.230,0:11:53.520
die einfach aus diesen bisher
eingeführten Operationen bestehen.

0:11:53.520,0:11:55.590
Und wenn man die ausrechnen
würde, würde man feststellen,

0:11:55.590,0:11:57.668
dass das hier eine sinnvolle Zahl ergibt.

0:11:57.668,0:11:58.380
Hier kommt: fünf plus null ist fünf, mal vier
ist zwanzig, und dann können wir drei durch

0:11:59.040,0:12:02.010
zwanzig rechnen.

0:12:02.010,0:12:05.910
Ob nun ganzzahlig oder nicht ganzzahlig
dividiert, zumindest kommt ein Ergebnis heraus.

0:12:05.910,0:12:08.940
Während bei diesem Ausdruck,
wenn man das ausrechnen wollte,

0:12:08.940,0:12:11.520
würde man auf Division durch null stoßen.

0:12:11.520,0:12:12.630
Aber der Punkt ist:

0:12:12.630,0:12:16.410
Mit den statischen Informationen, die
auf den Folien zuvor stehen, kann man

0:12:16.410,0:12:19.890
auch schon ohne Ausrechnen feststellen,
dass dieser Ausdruck nicht sicher ist.

0:12:22.920,0:12:28.440
Wenn man hier mit Sicherheit keinen Wert aus N+
stehen hat, könnte man mit den Informationen,

0:12:28.440,0:12:30.030
mit dieser Verfeinerung der Multiplikation hier,

0:12:30.030,0:12:34.110
feststellen, dass es nicht möglich
ist, diesen Ausdruck zu typen.

0:12:34.110,0:12:38.820
Also die Operation zu verwenden mit den Angaben,

0:12:38.820,0:12:43.380
die hier über die Parameter und Ergebnisse
stehen, um diesen Ausdruck zu bilden.

0:12:43.380,0:12:47.160
Man könnte also statisch verhindern, dass
dieser Ausdruck überhaupt hingeschrieben wird.

0:12:47.160,0:12:51.150
Und dann weiß man auch, dass zur
Laufzeit, zur Zeit, wo das System

0:12:51.150,0:12:56.860
dynamisch operieren soll, zum Beispiel
kein Division-durch-null-Fehler auftritt.

0:13:00.550,0:13:01.870
Und der Punkt ist hier natürlich:

0:13:01.870,0:13:03.850
Klar könnte ich auch was
ausrechnen für die Zahlen,

0:13:03.850,0:13:06.190
aber im Allgemeinen habe ich
ja nicht konkrete Zahlen.

0:13:06.190,0:13:10.270
Im Allgemeinen habe ich ja vielleicht einen
Ausdruck, der von Variablen im Programm abhängt.

0:13:10.270,0:13:11.620
Dann könnte ich nicht mehr sagen:

0:13:11.620,0:13:15.400
Ich rechne das zum Test mal aus, um zu sehen,
ob eine Division durch null herauskommt.

0:13:17.230,0:13:20.680
Wenn wir statische Informationen über
Operationen und über die Variablen haben,

0:13:20.680,0:13:23.350
können wir eben eine solche
Unterscheidung selbst dann treffen,

0:13:23.350,0:13:27.700
wenn wir Unbekannte da stehen haben und
deswegen nicht konkret ausrechnen können.

0:13:28.210,0:13:32.230
Das ist der Zweck dieser Art statischer
Informationen für Operationen.

0:13:36.880,0:13:40.090
Jetzt ist es so:

0:13:40.090,0:13:44.740
Für diese arithmetischen Operationen würden Sie
vielleicht meinen: Ja, was gewinnen wir denn hier?

0:13:44.740,0:13:45.550
Das ist doch einfach Schularithmetik.

0:13:45.550,0:13:51.430
Da wissen wir doch, was es heißt, zum Beispiel
bei der Division eine Null stehen zu haben.

0:13:51.430,0:13:52.240
Dass das ein Problem ist.

0:13:52.240,0:13:56.290
Der Punkt ist aber, dieser Umgang mit
solchen arithmetischen Ausdrücken,

0:13:56.290,0:13:58.060
oder auch Termen, wie sie
genannt werden, ist allgemeiner.

0:13:58.060,0:14:05.170
Während Sie das aus der Schule kennen, auch mit
solchen Termen gearbeitet und umgeformt haben,

0:14:05.170,0:14:10.278
ist es aus Modellierungssicht interessant, dass
so ein algebraischer Zugang (also die Operationen

0:14:10.278,0:14:19.060
über ihre Signaturen zu beschreiben, über Eingabe
und Ausgabe, Formate und die Regeln, nach denen

0:14:19.060,0:14:23.860
dann Terme aufgestellt werden) eben nicht nur
für Rechenoperationen auf Zahlen möglich ist.

0:14:23.860,0:14:27.760
Sondern ganz allgemein, für Operationen in
praktisch beliebigen anderen Anwendungsdomänen,

0:14:27.760,0:14:33.070
hat man es eben mit anderen Mengen und anderen
Operationsnamen zu tun und mit neuen Fragen dazu,

0:14:33.070,0:14:35.410
welche Kombinationen denn erlaubt sein sollen.

0:14:35.410,0:14:40.450
Wenn man das genau modelliert, dann hat man
über die jeweilige Anwendungsdomäne bereits

0:14:40.450,0:14:48.250
bestimmte Informationen festgehalten, bevor
man irgendwie anfängt, etwas zu implementieren.

0:14:48.250,0:14:56.200
Das sollte hier das Ziel bei der
Spezifikation von solchen Operationen sein.

0:14:56.200,0:14:59.320
Jetzt mache ich ein Beispiel, und zwar ein anderes
Beispiel als die arithmetischen Operationen.

0:14:59.320,0:15:06.340
Also stellen wir uns als andere Domäne vor,
dass wir Vektorgrafik betreiben wollen.

0:15:06.340,0:15:09.490
Also vielleicht möchten wir gern ein
Grafikprogramm oder irgendwie eine App

0:15:10.390,0:15:16.330
entwickeln, die Operationen zum Zeichnen
und Manipulieren von Bildern haben soll.

0:15:16.330,0:15:18.730
Und wir wollen dieses Programm jetzt modellieren.

0:15:18.730,0:15:22.450
Das heißt, wir werden zwar
immer noch Zahlen haben,

0:15:22.450,0:15:25.990
aber wir haben es jetzt nicht mehr *nur* mit
mathematischen Zahlenbereichen wie eben zu tun,

0:15:25.990,0:15:30.750
sondern wir müssen eben auch mit anderen
domänenspezifischen Typen arbeiten.

0:15:30.750,0:15:36.550
Also für Zahlenbereiche könnten wir jetzt
wie eben die mathematische Notation nehmen.

0:15:42.640,0:15:44.230
Vielleicht lernen Sie parallel gerade in der

0:15:44.230,0:15:49.750
GPT-Vorlesung (je nach Studiengang)
die Programmiersprache Python kennen.

0:15:49.750,0:15:55.000
Auch da gibt es spezielle Datentypen, zum Beispiel

0:15:55.000,0:16:01.840
eben die Zahltypen für ganze Zahlen und
für Fließkommazahlen, also Kommazahlen.

0:16:01.840,0:16:06.220
Vielleicht auch Strings, weil Sie die
Ausgaben in Textform haben wollen.

0:16:06.220,0:16:10.630
Und hier würden wir jetzt eben weitere
domänenspezifische Typen einführen wollen,

0:16:10.630,0:16:13.090
die nicht unbedingt in der
Programmiersprache vorliegen,

0:16:13.090,0:16:17.350
die wir aber brauchen, um unsere
Vektorgrafik-Domäne zu unterstützen.

0:16:17.350,0:16:19.330
Also was brauchen wir im Grafikbereich?

0:16:19.330,0:16:24.190
Farben vielleicht, Punkte,
Koordinaten, oder auch ganze Bilder.

0:16:27.520,0:16:30.040
Also, überlegen wir uns eine erste Operation.

0:16:30.040,0:16:34.000
Was könnten wir als Operation
haben, die ein Bild erzeugt?

0:16:34.000,0:16:38.140
Vielleicht möchten wir gerne
einen Kreis als Bild malen können.

0:16:38.140,0:16:39.490
Und dann müssen wir uns überlegen:

0:16:39.490,0:16:41.350
Was braucht der für Parameter?

0:16:41.350,0:16:42.370
Mindestens einen Radius.

0:16:42.370,0:16:44.575
Wir können auch sagen, vielleicht eine Farbe.

0:16:44.575,0:16:45.310
Aber man könnte auch sagen:

0:16:45.310,0:16:49.690
Erst mal ein Kreis an sich ist einfach dadurch
spezifiziert, dass es einen Radius gibt.

0:16:49.690,0:16:51.670
Und das könnte auch eine Kommazahl sein.

0:16:51.670,0:16:55.870
Deswegen führen wir eine Operation ein,
die heißt "circle", nimmt eine Zahl,

0:16:55.870,0:16:59.080
interpretiert diese Zahl als
Radius, und liefert ein Bild.

0:17:01.150,0:17:04.930
Vorstellen könnten wir uns das so, dass
wenn wir "circle" als Operation mit dem

0:17:04.930,0:17:07.840
Argument 3 aufrufen, dann
dieses Bild entstehen soll.

0:17:07.840,0:17:11.590
Ich werde jetzt immer solche
Bilder hier rechts einblenden,

0:17:11.590,0:17:16.440
als Vorstellung davon, was
die Operationen tun sollen.

0:17:16.440,0:17:22.410
Aber in der Modellierung an sich steckt
diese Information gar nicht drin.

0:17:22.410,0:17:22.830
Hier geht es ja nur darum:

0:17:22.830,0:17:26.460
Es gibt diese "circle"-Operation, die
nimmt eine Zahl und liefert ein Bild.

0:17:26.460,0:17:31.380
Dass es dieses Bild ist im konkreten Fall, wäre
gar nicht mehr Teil der statischen Modellierung,

0:17:31.380,0:17:33.390
sondern schon der dynamischen Modellierung.

0:17:33.390,0:17:35.820
Aber vielleicht hilft das hier
jetzt ein bisschen beim Verständnis,

0:17:35.820,0:17:37.560
was ich jeweils mit der
Operation eigentlich möchte.

0:17:42.540,0:17:47.550
Obwohl ich immer solche Beispiele zeigen werde,
ist der Fokus jeweils eigentlich auf diesen

0:17:47.550,0:17:51.690
Operationsnamen und ihren Signaturen
(Angaben über Ein- und Ausgaben).

0:17:54.660,0:18:02.430
Hier kurz festzuhalten wäre, dass 3 natürlich
eine ganze Zahl ist und keine Kommazahl,

0:18:02.430,0:18:06.030
aber dennoch hier auch verwendet werden
darf, wenn hier ja Kommazahlen erlaubt sind.

0:18:06.030,0:18:11.220
Weil letztlich die Menge der Kommazahlen eine
Obermenge der Menge der ganzen Zahlen ist.

0:18:11.220,0:18:13.740
Also jede ganze Zahl ist
natürlich auch eine "Kommazahl".

0:18:13.740,0:18:18.690
Also muss man hier nicht unbedingt 3,0
schreiben, man kann auch direkt 3 nehmen.

0:18:18.690,0:18:22.500
Zumindest notiere ich das jetzt
so in meiner Beispieldomäne.

0:18:29.280,0:18:30.240
Das wäre eine erste Operation.

0:18:30.240,0:18:32.040
Diese alleine wäre nicht super spannend.

0:18:32.040,0:18:35.070
Da könnte man genau Kreise malen,
oder immer genau einen Kreis.

0:18:35.070,0:18:35.640
Das ist dann ein Bild.

0:18:35.640,0:18:40.290
Dabei wollen wir es natürlich nicht
bewenden lassen, sondern beim Entwurf

0:18:40.290,0:18:44.340
unserer Vektorgrafik-App irgendwie
ein paar weitere Operationen vorsehen.

0:18:44.340,0:18:48.600
Und zum Beispiel könnte man beginnen, einfach
verschiedene geometrische Formen zuzulassen.

0:18:48.600,0:18:51.810
Etwa möchte man auch ein Rechteck zeichnen können.

0:18:51.810,0:18:52.770
Da müsste man sich überlegen:

0:18:52.770,0:18:53.910
Was sind die Parameter dafür?

0:18:53.910,0:18:55.470
Es müssten jetzt zwei sein.

0:18:55.470,0:18:57.930
Da gibt es keinen Radius, aber
vielleicht eine Breite und eine Höhe.

0:18:57.930,0:19:00.360
Und das Ergebnis ist wieder ein Bild.

0:19:00.360,0:19:06.450
Die Interpretation wäre, dass wenn ich zum
Beispiel "rectangle" mit 7 und 5 aufrufe,

0:19:06.450,0:19:08.130
ich ein solches Rechteck kriege.

0:19:08.130,0:19:14.280
Da ist schon eine Interpretation eingeflossen,
nämlich dass das erste Argument als die Breite

0:19:14.280,0:19:18.090
und das zweite Argument als die
Höhe interpretiert werden soll.

0:19:18.090,0:19:21.270
Das steckt in dieser Angabe hier nicht drin.

0:19:21.270,0:19:23.580
Als statische Information steckt nur drin:

0:19:23.580,0:19:26.310
Es gibt zwei Fließkomma-Argumente.

0:19:26.310,0:19:29.820
Und nicht wie die am Ende
genau zu dem Bild beitragen.

0:19:29.820,0:19:40.320
Was man sich hier auch fragen könnte, im Sinne
der arithmetischen Beispieldomäne vorhin:

0:19:40.320,0:19:42.630
Was passiert denn, wenn
eins der Argumente null ist?

0:19:42.630,0:19:44.640
Also schon bei dem Kreis könnte man sich fragen:

0:19:44.640,0:19:51.810
Was ist, wenn der Kreis mit dem Argument null
oder sogar mit negativen Radien aufgerufen wird?

0:19:51.810,0:19:57.990
Dem hätte man begegnen können, indem
man eben absichtlich noch eine Menge

0:19:57.990,0:20:02.610
einführt mit nur nicht-negativen Fließkommazahlen.

0:20:03.240,0:20:06.420
Oder man würde bei der Implementierung
dann Entscheidungen treffen,

0:20:06.420,0:20:08.460
wie mit solchen Randfällen umzugehen ist.

0:20:08.460,0:20:09.120
Also vielleicht:

0:20:09.120,0:20:12.240
Ein "circle" der Größe null
wäre einfach ein Punkt.

0:20:12.240,0:20:18.660
Ein Rechteck der Höhe null wäre
einfach ein horizontaler Strich.

0:20:18.660,0:20:22.290
Und zum Beispiel für negative
Argumente entweder immer sagen,

0:20:22.290,0:20:24.990
die werden nicht akzeptiert, oder
die werden wie null behandel.

0:20:26.430,0:20:28.230
Das ist hier nicht ausgedrückt.

0:20:28.230,0:20:33.870
Hier geht es erst mal darum, welche Kombinationen
prinzipiell erlaubt sind, syntaktisch sozusagen.

0:20:35.730,0:20:36.960
Ein paar weitere Beispiele.

0:20:36.960,0:20:38.580
Was könnten weitere Operationen sein?

0:20:38.580,0:20:41.310
Man könnte noch ein Quadrat einführen.

0:20:41.310,0:20:44.640
Braucht man vielleicht nicht, weil man
ein Quadrat als Rechteck darstellen kann.

0:20:46.020,0:20:49.290
Aber es werden vielleicht noch
andere allgemeine Operationen.

0:20:49.290,0:20:54.420
Zum Beispiel möchte man vielleicht allgemeine
Pfade zeichnen, also irgendwelche Strichfolgen,

0:20:54.420,0:20:59.040
die nicht genau etwa eine Box
wie dieses Rechteck ergeben.

0:20:59.040,0:21:01.650
Was braucht man da als Argumente?

0:21:01.650,0:21:03.930
Irgendwie Koordinaten, also Punkte.

0:21:03.930,0:21:08.130
Ein Punkt als eine Kombination aus x- und y-Wert.

0:21:08.130,0:21:10.200
Und für einen Pfad braucht man mehrere Punkte.

0:21:10.200,0:21:14.400
Also vielleicht so eine Liste, eine Auflistung
von mehreren solchen Koordinatenpaaren.

0:21:14.400,0:21:16.470
Man könnte sagen:

0:21:19.440,0:21:21.270
Ein Pfad hat als Argument eine Liste.

0:21:21.270,0:21:25.230
Das soll jetzt hier durch diese
eckigen Klammern angezeigt werden.

0:21:25.230,0:21:28.770
Und in dieser Liste können
Koordinatenpaare stehen.

0:21:28.770,0:21:35.350
Also (-1,0) wäre hier der erste Punkt, x-Achse
-1, y-Achse 0, und der nächste Punkt wäre hier.

0:21:35.350,0:21:36.940
Also hinter dem Punkt, Punkt,

0:21:36.940,0:21:41.140
Punkt würden sich weitere solche
Paare verstecken, zum Beispiel (1,2).

0:21:42.160,0:21:46.060
Hier scheint (3,0) zu sein und dann hier (6,4).

0:21:46.060,0:21:51.880
Also ich rufe die Pfadoperation mit einer
solchen Liste von Koordinatenpaaren auf,

0:21:51.880,0:21:53.290
und dann kommt ein Bild heraus.

0:21:53.290,0:21:55.480
In dem Fall eben diese Zickzack-Kurve.

0:21:58.720,0:22:01.240
Und vielleicht auch als weitere Operation:

0:22:01.240,0:22:05.560
Angenommen, wir wollen in unseren Bildern auch
Beschriftungen zulassen, also irgendwie Text.

0:22:05.560,0:22:08.860
Dann müssen wir eine Operation
haben, die Text in ein Bild umsetzt.

0:22:08.860,0:22:11.470
Und das könnte zum Beispiel einfach so sein:

0:22:11.470,0:22:13.540
Der Name "print" ist vielleicht recht naheliegend.

0:22:13.540,0:22:17.020
Und das Argument für diese
Operation wäre ein String, ein Text.

0:22:17.020,0:22:21.160
Und das Ergebnis wäre ein Bild,
das diesen Text darstellt.

0:22:21.160,0:22:23.530
Also zum Beispiel print("ABC").

0:22:25.090,0:22:28.930
Diese Hochkommas kennen Sie wahrscheinlich
auch, als Begrenzer für Strings in

0:22:28.930,0:22:33.550
vielen Programmiersprachen (oder in der
Programmiersprache, die Sie als erstes lernen).

0:22:33.550,0:22:38.530
Und dann wird das Ergebnis hier eben ein
Bild, das genau den Text ABC enthält.

0:22:41.800,0:22:44.110
So, damit könnten wir jetzt einige Sachen machen.

0:22:44.110,0:22:48.940
Genau genommen könnten wir entweder einen
Kreis zeichnen, oder ein Rechteck zeichnen,

0:22:48.940,0:22:55.930
oder so eine beliebige Sequenz von Strichen
zeichnen, oder eine Zeichenkette ausgeben.

0:22:57.100,0:23:00.010
Jetzt würden wir uns mehr Flexibilität wünschen.

0:23:00.010,0:23:02.800
Zum Beispiel ist diese
Zeichenkette hier jetzt sehr klein.

0:23:02.800,0:23:06.010
Vielleicht möchte man die
lieber größer dargestellt haben.

0:23:06.010,0:23:13.300
Die print-Operation haben wir so designt, dass sie
keine Angabe darüber enthält (etwa als Argument),

0:23:13.300,0:23:17.860
mit welcher Schriftgröße
man das ausdrucken möchte.

0:23:17.860,0:23:20.710
Das könnte man revidieren und sagen:

0:23:20.710,0:23:22.270
Wir führen hier ein Argument ein.

0:23:22.270,0:23:23.710
Dann hätten wir immer noch nicht die Möglichkeit,

0:23:23.710,0:23:27.430
zum Beispiel andere grafische
Objekte in ihrer Größe zu verändern.

0:23:27.430,0:23:29.590
Also allgemeiner wäre vielleicht, zu sagen:

0:23:30.730,0:23:36.130
Einen String auszugeben, erfolgt immer
in irgendeiner festen Schriftgröße.

0:23:36.670,0:23:40.060
Aber wenn wir einen String
größer dargestellt haben wollen,

0:23:40.060,0:23:42.970
dann gibt es dafür eine andere Operation,
die ein beliebiges Bild vergrößern kann.

0:23:42.970,0:23:46.030
Inklusive auch Bildern, die
mittels "print" erzeugt wurden.

0:23:46.030,0:23:52.480
Wenn wir das so entscheiden, dann hieße
das, wir würden eine Operation (und gleich

0:23:52.480,0:23:56.140
sogar mehrere Operationen) einführen,
um bestehende Figuren zu manipulieren.

0:23:56.140,0:24:01.990
Bei den bisherigen Operationen, die wir gesehen
haben, tauchte Picture immer nur als Ergebnis auf.

0:24:01.990,0:24:04.210
Wir stecken eine Zahl hinein, kriegen ein Bild.
Wir stecken zwei Zahlen hinein, kriegen ein Bild.

0:24:06.850,0:24:10.120
Wir stecken eine Liste von
Punkten hinein, kriegen ein Bild.

0:24:10.120,0:24:13.750
Wir stecken eine Zeichenkette
hinein, kriegen ein Bild.

0:24:13.750,0:24:15.220
Wenn wir darüber hinausgehen wollen,

0:24:15.220,0:24:18.580
könnten wir Operationen vorsehen,
die Bilder auch als Eingabe haben.

0:24:18.580,0:24:23.410
Und zum Beispiel für dieses Skalieren,
für die Größenänderung, könnten wir sagen:

0:24:23.410,0:24:27.670
Wir möchten gern eine Operation
haben, die "scale" heißt.

0:24:27.670,0:24:35.440
Sie kriegt ein Bild, kriegt zwei Zahlen,
die als Skalierung zu interpretieren sind.

0:24:35.440,0:24:38.522
Vergrößerung oder Verkleinerung, je
nachdem ob größer 1 oder kleiner 1.

0:24:38.522,0:24:42.370
Also je ein Faktor soll das
sein, in x- und y-Richtung.

0:24:42.370,0:24:42.790
Dann könnten wir sagen:

0:24:42.790,0:24:46.870
Gut, wenn wir das Bild nehmen, das durch
print("ABC") entsteht (das wäre dieses

0:24:46.870,0:24:52.600
kleine Bild hier), und wir skalieren das um
den Faktor 3 in sowohl x- als auch y-Richtung,

0:24:52.600,0:24:56.710
dann kriegen wir eben dieses
größere ABC-Schriftbild.

0:25:00.010,0:25:02.800
Das wäre eine Möglichkeit der
Manipulation bestehender Figuren.

0:25:02.800,0:25:03.811
Wir können uns weitere überlegen.

0:25:03.811,0:25:07.090
Wenn wir zum Beispiel den
Text auch einfärben wollen,

0:25:07.090,0:25:12.160
oder andere Figuren einfärben wollen, wäre
vielleicht eine "color"-Operation gut.

0:25:12.160,0:25:17.260
Die muss wieder ein Bild kriegen und
muss eine Farbe übergeben kriegen.

0:25:17.260,0:25:20.770
Es muss also irgendwie einen
Vorrat an Farben geben.

0:25:20.770,0:25:23.530
Das ist einfach eine neue Menge,
die irgendwo definiert wäre.

0:25:23.530,0:25:26.380
Und das Ergebnis wäre wieder ein Bild.

0:25:26.380,0:25:28.240
Und dann könnten wir zum Beispiel sagen:

0:25:28.240,0:25:31.750
Man nehme das Bild von eben
(noch vor dem Skalieren,

0:25:31.750,0:25:34.690
also die kleine Zeichenkette
"ABC"), und färbe sie rot.

0:25:34.690,0:25:36.880
Dann erhält man dieses Ergebnis.

0:25:36.880,0:25:40.000
Und gewollt wäre natürlich,
wenn wir das kombinieren,

0:25:40.000,0:25:44.200
sowohl "scale" als auch "color" aufrufen
(geschachtelte Operationen verwenden),

0:25:44.200,0:25:47.990
dann sollten wir die große
Zeichenkette in Rot erhalten.

0:25:47.990,0:25:50.300
Die Idee ist dann, dass hier ein Bild herauskommt,

0:25:50.300,0:25:52.370
das man wieder als Argument
hierfür verwenden kann.

0:25:53.420,0:25:55.940
Wir könnten diese Operationen natürlich
kombinieren, so wie wir in der Arithmetik

0:25:56.690,0:26:00.290
"Plus" und "Mal" und "Division" etc.
auch ineinander einsetzen können.

0:26:00.290,0:26:06.410
Und immer größere Ausdrücke kriegen, die
komplizierter sind, aber mit den Definitionen der

0:26:06.410,0:26:10.850
einzelnen Operationen ausgerechnet werden können,
indem wir mehrere Ausrechnungsschritte tun.

0:26:13.130,0:26:13.910
Was können wir noch wollen?

0:26:13.910,0:26:14.750
Skalieren, Einfärben.

0:26:14.750,0:26:16.460
Rotieren, zum Beispiel.

0:26:17.210,0:26:21.710
Unsere Rechtecke vorhin
waren immer achsenparallel.

0:26:21.710,0:26:24.170
Vielleicht wollen wir auch
Rechtecke haben, die schräg liegen.

0:26:24.170,0:26:27.770
Dann müssten wir die Möglichkeit
haben, ein Bild zu rotieren.

0:26:27.770,0:26:29.330
Also wir könnten sagen:

0:26:29.330,0:26:31.910
Unser Rechteck von vorhin, das
wäre der Ausdruck "rectangle(7,5)".

0:26:32.780,0:26:34.580
Das möchten wir gerne um einen Winkel rotieren.

0:26:34.580,0:26:38.420
Dann müssten wir irgendwie
festhalten, oder uns entscheiden,

0:26:38.420,0:26:40.790
wie dieser Winkel zu interpretieren ist.

0:26:40.790,0:26:45.530
Nehmen wir an, wir messen Winkel einfach in
Grad-Angaben und nicht irgendwie in Bogenmaß.

0:26:45.530,0:26:52.910
Dann entspricht 30 eben einem um diesen
Winkel hier gekippten Rechteck, wobei

0:26:52.910,0:26:56.000
das Rotieren immer um den Ursprung stattfindet.

0:26:56.000,0:27:04.100
So, was können wir jetzt tun?

0:27:04.100,0:27:09.140
Jetzt haben wir diese Bilder, die
wir ein bisschen verändern können.

0:27:09.140,0:27:11.900
Die sind aber immer um den Ursprung zentriert.

0:27:11.900,0:27:15.440
Was zum Beispiel auch heißt, dass einen
Kreis zu rotieren gar keinen Sinn ergibt.

0:27:15.440,0:27:21.320
Weil der Kreis um den Ursprung gebildet war.

0:27:21.320,0:27:24.650
Wenn wir den jetzt rotieren, und
dies immer um den Ursprung geschieht,

0:27:25.190,0:27:28.940
könnte man mit dem Kreis nichts anderes
tun als ihn zu malen und einzufärben.

0:27:31.610,0:27:33.920
Man könnte ihn noch skalieren und
daraus eine Ellipse machen, indem

0:27:33.920,0:27:35.630
man in x- und y-Richtung verschieden skaliert.

0:27:35.630,0:27:38.750
Aber man kann ihn zum Beispiel
nicht an irgendeiner anderen Stelle

0:27:38.750,0:27:41.180
zeichnen als im Ursprung des Koordinatensystems.

0:27:41.180,0:27:46.070
Das ist für eine allgemeine
Grafik-App sicherlich unattraktiv.

0:27:46.070,0:27:50.180
Also sollten wir noch mindestens eine
weitere Operation haben, die uns erlaubt,

0:27:50.180,0:27:55.580
auch Objekte an anderer Stelle
als am Ursprung zu zeichnen.

0:27:55.580,0:28:01.040
Und würden wir auch alle Zeichenketten,
die wir drucken wollen, immer alle am

0:28:01.040,0:28:03.230
Ursprung sich überlappen lassen,
so könnte man gar nichts lesen.

0:28:03.230,0:28:05.690
Also, was brauchen wir dafür?

0:28:05.690,0:28:08.060
Eine weitere Operation, um ein Bild zu bewegen.

0:28:08.060,0:28:09.890
Was braucht die für Argumente?

0:28:10.850,0:28:14.690
Erst mal das Bild, das bewegt werden soll,
und dann wahrscheinlich wieder zwei Parameter.

0:28:14.690,0:28:19.040
Wie hier für x- und y-Richtung, aber
eben nicht als Skalierungsfaktoren,

0:28:19.040,0:28:21.410
sondern als Verschiebungswerte.

0:28:21.410,0:28:26.000
Und das Ergebnis wäre natürlich ein Bild.

0:28:26.000,0:28:27.080
Also die Vorstellung ist:

0:28:27.080,0:28:31.850
Wenn wir einen Kreis des Radius
3 nehmen und den in x-Richtung um

0:28:31.850,0:28:36.080
2 und in y-Richtung um 1 verschieben,
erhalten wir eben die gleiche Form,

0:28:36.080,0:28:39.650
den gleichen Kreis, aber der befindet
sich jetzt an einer anderen Stell.

0:28:42.020,0:28:43.400
Und der Kreis ist dann ganz verschoben,

0:28:43.400,0:28:48.410
weshalb also der Mittelpunkt jetzt an
dieser neuen Position (2,1) liegen würde.

0:28:52.160,0:29:01.720
Dann könnten wir einzelne Formen
unserer Wahl, unserer Größe,

0:29:01.720,0:29:06.760
unserer Farbe, unserer Wahl der Position zeichnen.

0:29:06.760,0:29:08.770
Wir könnten allerdings nichts davon kombinieren.

0:29:08.770,0:29:13.330
Zum Beispiel ein Bild, das sowohl einen
Kreis als auch ein Rechteck enthält,

0:29:13.330,0:29:15.610
könnten wir so noch nicht darstellen.

0:29:15.610,0:29:19.960
Mit den Operationen, die wir bisher
haben, würden wir immer nur einzelne

0:29:19.960,0:29:25.780
geometrische Formen malen und
irgendwo positionieren können.

0:29:25.780,0:29:27.580
Also, was bräuchten wir noch?

0:29:27.580,0:29:30.370
Was wäre noch als sinnvolle
Operation denkbar oder wünschenswert?

0:29:30.370,0:29:33.190
Irgendetwas, mit dem man
mehrere Bilder kombinieren kann.

0:29:33.190,0:29:37.810
Und die einfachste Wahl wäre da einfach,
eine binäre Operation einzuführen,

0:29:37.810,0:29:42.040
also so wie das "Plus" bei den Zahlen ("+"
nimmt zwei Zahlen und liefert eine Zahl).

0:29:42.040,0:29:43.690
Wir hatten jetzt immer nur Operationen,

0:29:43.690,0:29:46.360
die höchstens ein Bild nahmen
und ein Bild zurückgaben.

0:29:46.360,0:29:49.540
Wenn wir Bilder kombinieren,
vielleicht überlappen wollen,

0:29:49.540,0:29:54.790
brauchen wir eine Operation, die
ein Bild aus Teilbildern komponiert.

0:29:54.790,0:29:57.400
Das könnte eben eine binäre
Operation sein mit zwei Argumenten,

0:29:57.400,0:30:00.640
jeweils Pictures, und sie
soll ein Picture liefern.

0:30:00.640,0:30:06.190
Wie sähe eine sinnvolle Verwendung dafür aus?

0:30:06.190,0:30:10.630
Zum Beispiel könnten wir
folgenden Ausdruck bilden:

0:30:10.630,0:30:14.320
Also irgendwie ein Pfad, den wir
vorhin schon mal gesehen haben.

0:30:14.320,0:30:16.450
Den färben wir noch blau ein.

0:30:16.450,0:30:18.310
Weil wir die Operationen kombinieren dürfen.

0:30:18.310,0:30:20.830
Das wäre dann ein Bildausdruck.

0:30:20.830,0:30:26.290
Und einen anderen Bildausdruck erhalten wir,
indem wir ein Stück Text ausgeben, es einfärben,

0:30:26.290,0:30:31.450
es geeignet rotieren und irgendwie aus dem
Ursprung an eine andere Stelle verschieben.

0:30:31.450,0:30:35.290
Und dann hätten wir ein Bild, das dieser
blauen Zickzack-Linie entspricht, und ein

0:30:35.290,0:30:39.520
Bild, das diesem geschickt
positionierten Text entspricht.

0:30:39.520,0:30:44.680
Und wenn wir das mit dieser neuen Operation
kombinieren, dann erhalten wir ein Bild,

0:30:44.680,0:30:45.640
in dem beides vorkommt.

0:30:45.640,0:30:49.870
Und jetzt könnte man mit diesen Zutaten und
der beliebigen Schachtelung von Operationen

0:30:49.870,0:30:56.830
(wie wir das hier schon sehen) schon recht
komplexe und interessante Bilder erstellen.

0:31:00.540,0:31:02.910
Ein bisschen zu beachten ist,

0:31:02.910,0:31:06.810
dass diese neue Operation jetzt
als Infix-Operation verwendet wird.

0:31:06.810,0:31:09.390
Das heißt, sie wird, anders
als "move" und "color" etc.,

0:31:09.390,0:31:12.000
nicht mehr mit Klammern um
ihre Argumente herum verwendet.

0:31:12.000,0:31:14.430
Sondern man schreibt die
einfach zwischen zwei Terme.

0:31:14.430,0:31:16.500
So wie Sie es auch aus der
Mathematik gewohnt sind,

0:31:16.500,0:31:20.209
aus der Arithmetik, dass das "Plus"
einfach infix zwischen zwei Zahlen steht.

0:31:20.209,0:31:24.150
Also infix im Sinne von "zwischen den
Operanden", zwischen den Argumenten.

0:31:24.150,0:31:27.990
Statt wie bei "move", "rotate", etc., dass
man die Argumente in Klammern schreibt.

0:31:27.990,0:31:33.330
Das ist eine übliche Verwendung,
gerade von solchen Symbol-Operationen.

0:31:33.330,0:31:35.580
Dabei kann man sich auch fragen:

0:31:35.580,0:31:38.880
Kann ich zum Beispiel die
Operation auf drei Bilder anwenden?

0:31:38.880,0:31:41.940
Wohl nicht direkt, weil hier
steht: es gibt zwei Bilder.

0:31:41.940,0:31:45.360
Aber so wie ich "Plus"
aufschreiben kann: 2 + 5 + 4.

0:31:45.360,0:31:49.260
Dann habe ich drei Zahlen addiert,
obwohl "Plus" eine binäre Operation ist.

0:31:49.260,0:31:51.720
Doch könnte ich auch hier mehr als zwei Bilder
kombinieren, indem ich einfach schreibe:

0:31:51.720,0:32:01.890
dieses Bild, Operationssymbol, das nächste Bild,
Operationssymbol, wieder nächstes Bild, etc.?

0:32:01.890,0:32:05.970
Für die Komedia-Studierenden zum
Beispiel als Erinnerung an die

0:32:05.970,0:32:09.120
Mathematische-Strukturen-Vorlesung,
da hatten wir Monoide betrachtet,

0:32:09.120,0:32:11.280
da ging es um assoziative
Operationen in der Algebra.

0:32:11.280,0:32:14.970
Hier würde man erwarten, dass das
eine solche assoziative Operation ist.

0:32:14.970,0:32:17.910
Die anderen Studierenden kennen Assoziativität

0:32:17.910,0:32:20.640
sicherlich auch zumindest als
Eigenschaft von "Plus" oder "Mal".

0:32:20.640,0:32:25.980
Dann ist es also okay, dieses
Operationssymbol auch zu verwenden,

0:32:25.980,0:32:29.670
wenn wir mehr als zwei Bilder
hintereinander kombinieren wollen.

0:32:29.670,0:32:40.060
So, jetzt habe ich einfach ein paar Operationen
entworfen und ein paar Beispiele gezeigt.

0:32:40.060,0:32:45.070
Ich werde natürlich jetzt keine Implementation
davon durchführen, darum geht es hier ja nicht.

0:32:45.070,0:32:50.470
Aber was hier interessant und wichtig ist, und
warum wir das einführen, ist dass wir anhand

0:32:50.470,0:32:55.930
solcher statischen Informationen eben bestimmte
Aufrufe / Kombinationen von Operationen als

0:32:55.930,0:32:58.060
sinnvoll oder auch als nicht
sinnvoll erkennen können.

0:32:58.060,0:32:59.830
Das ist der Aspekt, den ich vorher erwähnt hatte.

0:32:59.830,0:33:02.350
Dass solche statischen
Informationen dazu dienen können,

0:33:02.350,0:33:08.080
bestimmte potentielle Fehler letztlich
schon in der Modellierung auszuschließen,

0:33:08.080,0:33:10.240
sodass sie bei der Implementierung
nicht mehr auftreten können.

0:33:11.170,0:33:14.650
Typische Beispiele wären folgende:

0:33:14.650,0:33:17.830
Es macht zum Beispiel keinen
Sinn für die Operation,

0:33:17.830,0:33:22.900
die von mir eingeführt wurde, hier etwas
zu schreiben wie "circle-von-circle-3".

0:33:22.900,0:33:25.330
Also "circle(3)" ist ein sinnvoller Ausdruck.

0:33:25.330,0:33:30.700
Wir haben dann sogar vorhin auch das Bild gesehen,
das sich ergibt, wenn ich das interpretiere.

0:33:30.700,0:33:35.530
Aber es ergibt keinen Sinn, darum
noch einmal "circle" zu schreiben.

0:33:36.190,0:33:36.970
Warum nicht?

0:33:36.970,0:33:45.190
Weil "circle" laut der Signatur, die ich vorne auf
der Folie hatte, eine Zahl als Argument erwartet.

0:33:45.190,0:33:49.390
Was hier ja für diesen Ausdruck auch zutrifft.

0:33:49.390,0:33:56.050
Aber für den äußeren Aufruf ist das
Argument eben keine Zahl, sondern ein Bild.

0:33:56.050,0:34:00.040
Weil 3 eine Zahl ist, "circle-von-3" dann ein Bild

0:34:00.040,0:34:03.550
ist, und ich ein Bild nicht als
Argument in "circle" stecken kann.

0:34:04.420,0:34:07.420
Das wäre hier das Argument, warum
dieser Ausdruck nicht okay wäre.

0:34:07.420,0:34:11.020
Warum das zurückgewiesen wird, allein
schon anhand der statischen Informationen.

0:34:11.020,0:34:15.580
Bei der Implementierung, wenn wir eine
Programmiersprache benutzen, die solche

0:34:15.580,0:34:20.440
Signaturen von Operationen berücksichtigt, würden
wir eine Fehlermeldung des Compilers erwarten.

0:34:20.440,0:34:21.130
Dass er sagt:

0:34:21.130,0:34:23.260
Dieser Ausdruck macht keinen
Sinn, ich weigere mich,

0:34:23.260,0:34:27.520
überhaupt ein Programm dafür zu
erstellen, das dann ausführbar wäre.

0:34:27.520,0:34:37.860
Und man kann sich diverse weitere Fälle
überlegen, die okay sind und die nicht okay sind.

0:34:37.860,0:34:41.520
Auf der Folie habe ich mal so ein paar Fälle
aufgeführt, die jeweils nicht okay sind.

0:34:41.520,0:34:46.620
Jeweils mit einer kurzen intuitiven Erläuterung,
warum dieser Ausdruck nicht okay wäre.

0:34:46.620,0:34:48.000
Dieser Ausdruck wäre deswegen nicht okay,

0:34:48.000,0:34:52.710
weil "circle(3)" wieder ein Bild ist,
und das selbst kein druckbarer Text ist.

0:34:52.710,0:34:55.710
Also "print" erwartet eine Zeichenkette,

0:34:55.710,0:34:58.950
einen String wie einen Text, der
dann in ein Bild umgewandelt wird.

0:34:58.950,0:35:02.010
Ich kann "print" nicht ein
schon fertiges Bild übergeben.

0:35:02.010,0:35:03.930
Dann wüsste "print" nicht, was es drucken soll.

0:35:03.930,0:35:07.410
Es würde, so wie hier die
Operationen interpretiert

0:35:07.410,0:35:10.320
sind, auch nicht irgendwie
den Text "circle(3)" drucken.

0:35:10.320,0:35:12.540
Dafür hätte der in
Anführungszeichen stehen müssen.

0:35:12.540,0:35:16.530
Ja, "print" kann zwar einen beliebigen Text
ausdrucken, es müsste aber irgendwie klar sein,

0:35:16.530,0:35:19.800
durch Anführungszeichen, dass man
da wirklich eine Zeichenkette hat

0:35:19.800,0:35:23.820
und nicht einen anderen Ausdruck, der
als ein Bild zu interpretieren ist.

0:35:27.780,0:35:31.530
Aus gleichen Gründen wäre so etwas
wie "print-von-3" nicht okay,

0:35:31.530,0:35:32.880
zumindest in meiner Interpretation.

0:35:33.480,0:35:38.970
Es gibt Programmiersprachen, wo hier einfach
still und leise, wenn da eine 3 steht,

0:35:38.970,0:35:42.540
das implementiert würde als die Zeichenkette "3".

0:35:42.540,0:35:45.420
Das will ich hier nicht zulassen.

0:35:45.420,0:35:51.150
Ich hatte mir Strings und
Zahlen als verschiedene Dinge

0:35:51.150,0:35:54.750
vorgestellt, beziehungsweise
sie verschieden benannt.

0:35:55.320,0:36:01.050
Das heißt, "print-von-3" wäre hier in meiner
Beispieldomäne jetzt kein gültiger Ausdruck,

0:36:01.050,0:36:05.280
weil es nicht stimmt, dass die
3 an sich eine Zeichenkette ist.

0:36:05.280,0:36:08.040
Dafür müsste sie in Hochkommas
eingeschlossen sein.

0:36:09.870,0:36:13.560
Und für keine von diesen Beobachtungen
hier muss ich irgendwie das Programm

0:36:13.560,0:36:16.230
laufen lassen und die Sachen malen,
also irgendwie Bilder erzeugen.

0:36:16.230,0:36:19.170
Das kann ich alles schon anhand der
statischen Informationen bestimmen.

0:36:19.170,0:36:22.530
Hier ist ein anderer Fehler.

0:36:22.530,0:36:25.800
Hier ist der Fehler: wir haben "print"
auf eine Zeichenkette angewandt,

0:36:25.800,0:36:28.680
es kommt ein Bild heraus, hier möchte
ich gern skalieren mit dem Faktor 3.

0:36:28.680,0:36:30.900
Warum ist das dennoch falsch?

0:36:30.900,0:36:32.760
Weil das die falsche Anzahl von Argumenten hat.

0:36:32.760,0:36:33.450
Ich habe vorne eingeführt:

0:36:33.450,0:36:36.870
"scale" nimmt zusätzlich zu dem Bild
immer zwei Argumente, also zwei Zahlen,

0:36:36.870,0:36:39.240
um in x- und y-Richtungen skalieren zu können.

0:36:39.240,0:36:40.800
Wenn ich eins davon vergesse,

0:36:40.800,0:36:44.250
würde ich hier erwarten, dass das
ein nicht gültiger Ausdruck ist.

0:36:44.250,0:36:48.490
Also selbst wenn man nur einen Faktor
zur Skalierung möchte, muss man ihn

0:36:48.490,0:36:52.540
zweimal angeben, um ihn für sowohl
x- als auch y-Richtung zu verwenden.

0:36:52.540,0:36:58.900
Beim Einfärben, da brauchen wir ein
Bild und eine Farbe zum Einfärben.

0:36:58.900,0:37:01.411
Aber spezifiziert war das als:

0:37:01.411,0:37:03.490
Man gebe erst das Bild und dann die Farbe an.

0:37:03.490,0:37:07.360
Und wenn ich das falsch herum mache, würde ich
auch hier erwarten, dass das zurückgewiesen wird.

0:37:14.620,0:37:18.970
Noch mal eher ein Fehler der Art wie oben.

0:37:18.970,0:37:23.740
Also "rotate" erwartet ein Bild und einen Winkel,

0:37:23.740,0:37:27.910
und nicht etwa zwei Winkelangaben
oder irgendetwas, das eine Zahl ist.

0:37:27.910,0:37:33.670
Hier vorne müsste ein Bild stehen, und die
Zahl 30 an sich ist erst mal kein Bild.

0:37:33.670,0:37:38.890
Man kann 30 drucken mit "print(30)", dann
hätte man ein Bild, das man rotieren könnte.

0:37:38.890,0:37:45.520
Aber die Zahl 30 selbst ist kein Bild
und kann deswegen nicht rotiert werden.

0:37:45.520,0:37:48.610
Unser Kombinationsoperator,
der war gedacht für Bilder.

0:37:48.610,0:37:54.190
Also wie eher gesagt, die Angabe war
für ein Picture und auch ein Picture,

0:37:54.190,0:37:55.660
und das Ergebnis wäre ein Picture.

0:37:55.660,0:38:00.430
Für "ABC" und "DEF" könnte man sich vorstellen,
dass man die auch irgendwie zusammenpacken möchte.

0:38:00.430,0:38:03.760
Vielleicht will man dann die
Zeichenkette "ABCDEF" herauskriegen.

0:38:03.760,0:38:06.040
Dafür müsste man aber eine
andere Operation einführen.

0:38:06.040,0:38:12.340
Die Operation "und" mit diesem Symbol wurde
eingeführt als Operation zwischen Bildern.

0:38:12.340,0:38:17.935
Und "ABC" sowie "DEF" sind eben keine Bilder.

0:38:17.935,0:38:19.120
Also wir haben eine ganze Reihe von Fehlern,

0:38:19.120,0:38:25.660
die man ausschließen könnte, indem man sich
einfach an die Operations-Signaturen hält.

0:38:25.660,0:38:29.770
Umgekehrt heißt das natürlich nicht, dass alle
Programmierfehler automatisch erkennbar sind.

0:38:29.770,0:38:34.480
Also etwa bei der Rechteck-Operation
war die Forderung:

0:38:34.480,0:38:35.680
Man muss zwei Zahlen angeben.

0:38:35.680,0:38:40.570
Und ich hatte die erste Zahl als Breite
und die zweite als Höhe interpretiert.

0:38:40.570,0:38:43.270
Aber das steckt natürlich in der Signatur,

0:38:43.270,0:38:49.420
in dieser Angabe auf der
entsprechenden Folie, nicht drin.

0:38:49.420,0:38:52.090
Hier, daraus kann man nicht erkennen,
was die Höhe und was die Breite ist.

0:38:52.090,0:38:52.510
Das heißt:

0:38:52.510,0:39:00.820
Auch wenn ich eigentlich so ein breiteres
als höheres Rechteck zeichnen möchte,

0:39:00.820,0:39:05.440
und aus Versehen aber "rectangle(5,7)"
schreibe statt "rectangle(7,5)",

0:39:05.440,0:39:10.930
wäre das ein Fehler, der nicht
statisch erkannt werden kann.

0:39:11.500,0:39:14.050
Denn diese Rolle dieser beiden Argumente,

0:39:14.620,0:39:19.570
die ist nicht durch die statischen Angaben
von den vorherigen Folien festgehalten.

0:39:19.570,0:39:20.260
Das heißt:

0:39:20.260,0:39:24.010
Ein Fehler, den ich da mache, ist einfach ein
Fehler, der mir erst dynamisch zur Laufzeit,

0:39:24.010,0:39:27.580
zur Ausführungszeit meiner App /
meines Programms auffallen würde.

0:39:27.580,0:39:32.200
Aber eine ganze Reihe von möglichen Fehlern
wird eben bereits statisch abgefangen.

0:39:32.200,0:39:37.840
Und je nach Programmiersprache sind
hier natürlich auch mehr oder weniger

0:39:37.840,0:39:42.160
solcher Fehler akzeptabel, oder
werden sozusagen durchgewunken.

0:39:42.160,0:39:44.470
Also in Python würde "print(3)"
wahrscheinlich funktionieren.

0:39:44.470,0:39:45.520
Das würde einfach interpretiert.

0:39:45.520,0:39:49.270
In meiner Domäne hier hatte ich
festgehalten, dass ich das nicht möchte.

0:39:49.270,0:39:52.840
Dass da also explizit eine
Zeichenkette stehen muss.

0:39:56.920,0:40:01.870
Das ist praktisch das Ende dieses Teils.

0:40:01.870,0:40:05.200
Eine kleine Bemerkung, eine kleine
Notiz, möchte ich noch machen.

0:40:05.200,0:40:11.770
Und zwar für diejenigen von Ihnen, die
Programmiersprachen wie C oder Java kennen.

0:40:11.770,0:40:16.240
Das muss nicht unbedingt für alle der Fall sein,
weil zum Beispiel die Programmiereinführung bei

0:40:16.240,0:40:20.650
uns mittlerweile mit Python stattfindet,
für Komedia und Angewandte Informatik.

0:40:20.650,0:40:24.340
Aber wenn Sie zum Beispiel aus
der Schule C oder Java kennen,

0:40:24.340,0:40:30.190
dann kennen Sie einerseits das Konzept von solchen
Operationen, solchen Angaben zu Signaturen.

0:40:30.190,0:40:32.380
Andererseits kennen Sie dann
eine andere Syntax dafür.

0:40:32.380,0:40:35.020
Also da wird das nicht so mathematisch angegeben.

0:40:35.020,0:40:39.400
Deswegen eine kleine Folie, wo einfach
diese Verbindung hergestellt wird,

0:40:39.400,0:40:42.340
wie das einander entspricht.

0:40:42.340,0:40:46.420
Also diese "rectangle"-Operation
zum Beispiel, die ich definiert

0:40:46.420,0:40:54.760
oder deklariert habe, die kriegt zwei
Zahlen übergeben und liefert ein Bild.

0:40:54.760,0:40:59.920
Die entspräche in C oder Java,
und noch vielen anderen meist

0:40:59.920,0:41:01.900
objektorientierten oder einfach
imperativen Programmiersprachen,

0:41:02.480,0:41:06.260
einer Deklaration folgender Art (wenn das
denn getypte Programmiersprachen sind):

0:41:06.800,0:41:11.630
Der Name "rectangle" würde hier als
Name einer Funktion verwendet werden.

0:41:14.780,0:41:18.860
Der Ergebnistyp, also was herauskommt
(was hier in der mathematischen Notation

0:41:18.860,0:41:24.980
als letzte Menge steht), wird
dann oft zuerst angegeben.

0:41:24.980,0:41:29.600
Also "rectangle" liefert ein Bild
und kriegt die Argumente übergeben,

0:41:29.600,0:41:32.570
die hier links von dem Pfeil stehen.

0:41:32.570,0:41:38.600
Also hier stünde dann, dass zwei
Fließkommazahlen übergeben werden.

0:41:38.600,0:41:40.490
Und oftmals wird dabei dann in der

0:41:40.490,0:41:43.490
Programmiersprache auch direkt ein
Name für die Parameter vergeben.

0:41:43.490,0:41:47.780
Das liefert dadurch ein klein wenig
mehr Information, wenn man denn dann

0:41:47.780,0:41:51.290
x und y auch geometrisch bereits als
die x- und y-Koordinate interpretiert.

0:41:51.290,0:41:53.090
Es könnten dafür beliebige Namen stehen,

0:41:53.090,0:41:56.750
aber da werden natürlich gerne Namen
vergeben, die auch schon ein bisschen

0:41:56.750,0:42:01.640
etwas über die Intention der Operation
und der Verwendung der Argumente aussagen.

0:42:03.710,0:42:06.860
Also das ist hier einfach deswegen angemerkt,

0:42:06.860,0:42:11.570
weil viele von Ihnen vielleicht
diese Art Notation kennen.

0:42:11.570,0:42:16.700
Und dann sollten Sie es einfach sehr direkt darauf
matchen können, wie ich jetzt hier gerade in den

0:42:16.700,0:42:23.465
Folien die Operationen deklariert habe, und wie es
auch in der entsprechenden Übung passieren wird.

0:42:23.465,0:42:26.840
Also das sind fast die gleichen
Informationen, nur anders aufgeschrieben.
