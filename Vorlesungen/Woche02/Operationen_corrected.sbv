0:00:00.000,0:00:07.410
Having dealt with graphs in
the last video, and having done

0:00:07.410,0:00:15.870
so using this little puzzle, this video will
on the one hand be about something much

0:00:15.870,0:00:23.880
more computer science specific, and on the
other hand it won't be about graphs either.

0:00:23.880,0:00:28.380
I had said that we will be
doing a lot of modeling with graphs, but

0:00:28.380,0:00:34.620
we actually need (especially in preparation for
UML) one more ingredient that is textual.

0:00:34.620,0:00:36.750
Namely, static
modeling of operations.

0:00:37.800,0:00:40.890
And that's what this video
is going to be about.

0:00:40.890,0:00:47.430
Because that's a prerequisite
and preparation for object-oriented class

0:00:47.430,0:00:52.620
design, or modeling classes
and especially their methods.

0:00:52.620,0:00:54.210
But we will
come to that then.

0:00:54.210,0:00:58.500
First of all still quite
general and also detached from UML.

0:00:58.500,0:01:01.140
In fact,
operations play a

0:01:01.140,0:01:04.770
role in mathematics as well as
in computer science independent of object orientation.

0:01:05.520,0:01:10.650
What are we talking about specifically,
also in the context of computer science?

0:01:10.650,0:01:13.050
Let's assume we want to
design a system in computer

0:01:13.050,0:01:15.450
science, be it a
program or a database.

0:01:15.450,0:01:17.850
Then often the
first question is,

0:01:17.850,0:01:20.460
which operations should
be offered and implemented.

0:01:20.460,0:01:24.810
And at least as importantly,
beside simply the names of operations,

0:01:24.810,0:01:28.080
also on which data
they are to work.

0:01:28.080,0:01:31.950
This is
about static modeling.

0:01:31.950,0:01:33.480
Ultimately, it is about
the structure of the system

0:01:33.480,0:01:36.750
or the functionalities and
services offered by the system.

0:01:36.750,0:01:42.150
So it is not about
what exactly the operations will do,

0:01:42.150,0:01:46.470
but first of all for example which
calls / uses should be syntactically allowed.

0:01:46.470,0:01:50.700
What at all
sensible operation uses should

0:01:50.700,0:01:53.670
be, and also how
operations can be combined.

0:01:53.670,0:01:56.250
Usually a system will
consist of many functionalities, which

0:01:56.250,0:02:01.110
may have to
be used in combination.

0:02:03.060,0:02:05.220
And at least that
would be important for documentation.

0:02:06.090,0:02:13.950
So we can learn about
the system simply by capturing

0:02:13.950,0:02:17.190
this static information, even without
having to look at the implementation.

0:02:17.190,0:02:21.390
And ideally it would also
help with the implementation, for

0:02:22.200,0:02:27.780
example by precisely recording which cases of
input have to be handled at all.

0:02:27.780,0:02:33.540
Or by using consistency
checks to possibly avoid certain

0:02:33.540,0:02:36.720
errors, even before testing
or trying to prove anything.

0:02:36.720,0:02:40.110
Simply by having
recorded beforehand what the

0:02:40.110,0:02:43.950
operations are called (the names are
also important), but also on which

0:02:43.950,0:02:50.010
types of data they operate and
which combinations of operations should be allowed.

0:02:51.630,0:02:55.440
Then, during programming, during implementation,
errors can be uncovered that

0:02:55.440,0:02:59.130
might otherwise only be noticed during
operation or when the system has been

0:02:59.130,0:03:00.870
implemented and is
to be tested.

0:03:03.240,0:03:04.890
I explain first
at a very simple

0:03:04.890,0:03:07.140
example, so to speak
at a very simple domain.

0:03:07.800,0:03:10.680
Operations always refer to
some special application area.

0:03:10.680,0:03:12.930
And the application domain
that you know from school,

0:03:12.930,0:03:16.650
where you have encountered
operations, is simply arithmetic.

0:03:16.650,0:03:20.250
So the arithmetic operations, they
are called: "plus", "minus", "times", etc.

0:03:20.250,0:03:22.350
These are of course
operations in this sense.

0:03:22.350,0:03:25.530
And depending on what we
then work with in a

0:03:25.530,0:03:28.050
system, we naturally have to
do with more than just numbers.

0:03:28.050,0:03:29.790
But numbers
will probably always

0:03:29.790,0:03:32.250
be involved in some
way in a program.

0:03:32.250,0:03:34.620
So let's
imagine, naively:

0:03:34.620,0:03:37.290
We might want to
design a calculator app.

0:03:37.290,0:03:42.450
Then the relevant operations we
probably want to offer are at

0:03:42.450,0:03:45.030
least the
usual arithmetic operations.

0:03:45.030,0:03:46.830
And maybe
we've decided that

0:03:46.830,0:03:50.325
we want to take the
set of natural numbers, including zero.

0:03:50.325,0:03:54.900
So we don't do fractional
numbers first, floating point numbers.

0:03:54.900,0:03:57.210
Then we
could say:

0:03:57.210,0:04:01.710
Well, then addition is a binary
operation (because it takes two arguments,

0:04:01.710,0:04:07.110
namely a natural number twice
each) and returns a natural number.

0:04:07.110,0:04:08.340
This is set
notation: a function.

0:04:08.340,0:04:14.300
A function, given its range of
values and its range of images.

0:04:14.300,0:04:19.070
The Komedia students
should know this

0:04:19.070,0:04:22.970
as notation from the
second semester math lecture.

0:04:22.970,0:04:24.530
The computer science students
and the ISE students from

0:04:24.530,0:04:28.010
their respective courses where
set theory is done.

0:04:28.010,0:04:30.290
Probably, for example, Discrete
Mathematics for the Applied Computer

0:04:30.290,0:04:32.060
Science
students.

0:04:32.060,0:04:38.090
I assume that's where it comes in
as notation very early in the semester.

0:04:38.090,0:04:44.210
Otherwise, at this moment, simply
an operation name "plus", two arguments,

0:04:44.210,0:04:45.980
each natural numbers
(N for natural numbers).

0:04:45.980,0:04:47.750
Result also
a natural number.

0:04:47.750,0:04:49.040
And
of course:

0:04:49.040,0:04:52.220
If we have several operations
(one wants to have multiplication too,

0:04:52.220,0:04:55.310
for instance), then they have a different
name (but here the same type, the

0:04:55.310,0:04:57.290
same information about
input and output values).

0:05:00.020,0:05:04.340
And, let's
say, maybe division.

0:05:04.910,0:05:08.978
Subtraction could also be imagined, but
already with division the question arises:

0:05:08.978,0:05:14.090
Of what type should the
output value be here anyway?

0:05:14.090,0:05:17.150
And we
could say:

0:05:17.150,0:05:18.470
Well, we know
what division is.

0:05:18.470,0:05:20.510
But strictly speaking, at the
moment this is only information

0:05:20.510,0:05:24.470
about the parameters
and the results.

0:05:24.470,0:05:27.050
So here also, if
we know "plus" as addition,

0:05:27.050,0:05:29.600
here is not yet
recorded what operations actually do.

0:05:29.600,0:05:35.960
Right now we're trying to figure out
what their input and output ranges are.

0:05:35.960,0:05:40.670
And probably here, for example,
you would want to prohibit at

0:05:40.670,0:05:44.660
least division by zero, so that that
just can't be called with five and zero.

0:05:44.660,0:05:45.530
Because it
says up here:

0:05:45.530,0:05:48.110
Let N be the set
of natural numbers including zero.

0:05:48.110,0:05:54.920
So you could decide here to say,
first (before deciding what the output range

0:05:54.920,0:06:00.230
will be) refine the
second input range a bit.

0:06:00.230,0:06:02.660
Restrict it a
bit by saying:

0:06:02.660,0:06:08.630
We take there the set N+
as notation for only positive natural numbers.

0:06:08.630,0:06:12.830
Then, for example, one
would statically define the operation

0:06:12.830,0:06:15.410
to simply forbid the
second argument to be zero.

0:06:15.410,0:06:20.300
Then, of course, you can
use that in fewer situations.

0:06:20.300,0:06:24.200
You can still use
this for natural numbers that

0:06:24.200,0:06:27.740
are positive, but just not for
zero itself as a second argument anymore.

0:06:27.740,0:06:30.290
In the first position, you would
still be allowed to have zero.

0:06:30.290,0:06:31.940
So zero by
five would go on.

0:06:33.620,0:06:38.060
Then you would have to somehow
think about the output range as well.

0:06:38.060,0:06:38.990
Above
all:

0:06:38.990,0:06:39.740
What does
one want here?

0:06:39.740,0:06:43.880
So if you have five and
three as arguments (which would fit each,

0:06:43.880,0:06:47.990
because three is a positive natural
number), what should the result be?

0:06:47.990,0:06:52.670
Should it be 1.666, or
maybe just 1 rounded down?

0:06:52.670,0:06:57.380
Does one do integer division, or
does one want to support rational numbers?

0:06:57.380,0:07:00.950
That is exactly the decision one
makes now in designing this operation.

0:07:00.950,0:07:04.160
Where you decide what
range you want here.

0:07:04.160,0:07:06.530
That would be
the decision between:

0:07:06.530,0:07:09.200
I only allow
natural numbers here.

0:07:09.200,0:07:14.720
Then I also have to allow zero because of 0 /
5 = 0, and for five by three I would want to

0:07:14.720,0:07:17.690
return 1 (so divide by
integer and discard the remainder).

0:07:17.690,0:07:19.760
Or do I want
to support rational numbers?

0:07:19.760,0:07:22.400
Then I would have
to provide already here in

0:07:22.400,0:07:25.850
the static design of the operation
that rational numbers may be there.

0:07:25.850,0:07:28.010
Which of
course contain the

0:07:28.010,0:07:31.970
natural numbers, but just also
provide other candidates as outputs.

0:07:31.970,0:07:34.520
And perhaps one
would even want both.

0:07:34.520,0:07:36.665
So the mathematicians like
to do that, of course.

0:07:36.665,0:07:40.460
They always use the same
symbol, overloaded in a certain sense,

0:07:40.460,0:07:43.100
so that it can
depend, for example, on

0:07:43.100,0:07:47.750
the context, which expression exactly is
wanted (the integer or the non-integer).

0:07:49.940,0:07:51.710
And, of course, there is
no real "right" or "wrong",

0:07:51.710,0:07:52.910
no right
or wrong decision.

0:07:52.910,0:07:54.020
It depends on the
purpose of the application.

0:07:54.020,0:07:56.030
So you
can't say:

0:07:56.030,0:07:59.120
This is the right choice
and this is the wrong choice.

0:07:59.120,0:08:00.080
That would
be nonsense.

0:08:00.080,0:08:04.550
Ultimately, it is precisely part
of modeling to work out:

0:08:04.550,0:08:08.270
In the current application
context, what is actually

0:08:08.270,0:08:16.610
the desired area
that should be here?

0:08:16.610,0:08:20.870
This could go as far as perhaps supporting
both and then providing suitable mechanisms in the

0:08:20.870,0:08:27.575
system so that this can be decided
in each case depending on the current situation.

0:08:27.575,0:08:29.960
Or at least one would have
to record which variants are available.

0:08:32.370,0:08:35.880
Of course, you also have to be careful
that if you take the rational numbers, for

0:08:35.880,0:08:37.980
example, you suddenly bring
a lot more into play.

0:08:37.980,0:08:41.910
Not only the rational numbers, i.e.
the fractional numbers, but also negative numbers.

0:08:41.910,0:08:45.660
Because the natural numbers, whether with or
without zero, were at least not negative.

0:08:45.660,0:08:50.250
If I choose the rational numbers here, I
would also have to deal with the fact

0:08:50.250,0:08:54.900
that I would then have negative numbers with
them (if I don't limit myself here to

0:08:54.900,0:08:57.600
the only positive
and non-negative rational numbers).

0:08:57.600,0:09:00.090
So this is the decision
to make at these points.

0:09:02.910,0:09:07.500
And of course, once I've done that, so
once I've introduced N+ or Q instead of

0:09:07.500,0:09:10.350
N, there's also the question
of what about the other operations.

0:09:10.350,0:09:14.970
So "plus" and so on, which before
was only in play for the natural numbers.

0:09:14.970,0:09:19.020
As soon as I now have
introduced for example this extra quantity,

0:09:19.020,0:09:23.670
in order to be able to deal with the
division by zero (by forbidding), one asks oneself also:

0:09:23.670,0:09:28.560
What about the operation
"plus" that existed before?

0:09:28.560,0:09:31.230
Does this perhaps also somehow
behave differently when one of the

0:09:31.230,0:09:34.050
two argument sets
is replaced by N+?

0:09:34.050,0:09:36.870
So one would
then ask next:

0:09:36.870,0:09:44.520
What would happen now that we
have several different set ranges in play?

0:09:44.520,0:09:48.960
What does that mean for the
static information about the other operations?

0:09:48.960,0:09:52.320
Can we perhaps make those more precise as well,
or do we need to make any changes there?

0:09:53.250,0:09:55.470
In fact, in the specific case,
one can make them more precise.

0:09:55.470,0:09:55.890
Because
you know:

0:09:55.890,0:10:01.140
If you have the addition and at
least one of the two summands is

0:10:01.140,0:10:02.430
positive, then the
result is also positive.

0:10:02.430,0:10:04.770
Before, it said: N
and N goes to N.

0:10:04.770,0:10:07.440
Now we
can additionally state:

0:10:07.440,0:10:15.060
If one of the two parameters, for example
the first one, is a positive number with certainty,

0:10:15.060,0:10:17.340
then after the addition the
result would also be positive.

0:10:17.340,0:10:18.780
That is
then more information.

0:10:18.780,0:10:23.400
So statically, we then know more about the
result than before, where there was only N here.

0:10:23.400,0:10:26.040
That would also have allowed
zero to come out there.

0:10:26.850,0:10:30.540
This will not happen if at least one
of the two arguments secured is not zero.

0:10:32.220,0:10:36.360
Of course, this could be done in
the same way for the other position.

0:10:36.360,0:10:39.960
And one could also hold,
for the multiplication for example,

0:10:39.960,0:10:43.860
that if both arguments are
positive, also the result is positive.

0:10:44.490,0:10:50.760
But of course not this
information, because it would be wrong.

0:10:50.760,0:10:57.660
It is not true that a positive number
times a natural number is always a positive number.

0:10:57.660,0:11:01.740
So here there is
really potential for distinction

0:11:01.740,0:11:05.400
between the operations, which can and
should be held on this operation.

0:11:06.390,0:11:09.510
So then we haven't quite
defined exactly what multiplication does.

0:11:09.510,0:11:15.090
But this restriction, that unlike addition, not
simply the fact that one of the

0:11:15.090,0:11:19.680
arguments is positive is enough for the
result to be positive as well, that

0:11:19.680,0:11:27.540
can already be held here as
a distinction between these two operations.

0:11:27.540,0:11:28.680
Why
all this?

0:11:28.680,0:11:31.500
Because on the basis
of this static information,

0:11:31.500,0:11:35.730
i.e. without having an implementation of
the operation (without really calculating anything),

0:11:35.730,0:11:40.860
we can already determine
whether certain expressions, certain terms,

0:11:40.860,0:11:45.330
certain formulas, which can be written
down, are okay or not okay.

0:11:45.330,0:11:49.230
We have two
formulas here that simply

0:11:49.230,0:11:53.520
consist of these operations that
have been introduced so far.

0:11:53.520,0:11:55.590
And if you were to
work those out, you would find

0:11:55.590,0:11:57.668
that this gives you
a number that makes sense.

0:11:57.668,0:11:58.380
Here comes: five plus zero is five, times
four is twenty, and then we can calculate three

0:11:59.040,0:12:02.010
by
twenty.

0:12:02.010,0:12:05.910
Whether dividing by an integer or
not, at least a result comes out.

0:12:05.910,0:12:08.940
Whereas with this expression, if
you wanted to work it

0:12:08.940,0:12:11.520
out, you would run
into division by zero.

0:12:11.520,0:12:12.630
But the
point is:

0:12:12.630,0:12:16.410
With the static information that is
on the slides before, you can tell

0:12:16.410,0:12:19.890
that this expression is not
safe even without calculating it out.

0:12:22.920,0:12:28.440
If you don't have a value from N+
standing here with certainty, you could use the information,

0:12:28.440,0:12:30.030
with this refinement
of multiplication here,

0:12:30.030,0:12:34.110
to determine that it's not
possible to type this expression.

0:12:34.110,0:12:38.820
So to use the
operation with the information

0:12:38.820,0:12:43.380
that is here about the parameters
and results to type this expression.

0:12:43.380,0:12:47.160
So you could statically prevent this
expression from being written down at all.

0:12:47.160,0:12:51.150
And then you also know that at runtime,
at the time when the system is supposed

0:12:51.150,0:12:56.860
to operate dynamically, there is
no division-by-zero error, for example.

0:13:00.550,0:13:01.870
And the point
is here, of course:

0:13:01.870,0:13:03.850
Sure I could calculate
something for the numbers,

0:13:03.850,0:13:06.190
but in general I
don't have concrete numbers.

0:13:06.190,0:13:10.270
In general, I might have an expression
that depends on variables in the program.

0:13:10.270,0:13:11.620
Then I could
not say more:

0:13:11.620,0:13:15.400
I'll calculate this for a test to
see if a division by zero comes out.

0:13:17.230,0:13:20.680
If we have static information
about operations and about the

0:13:20.680,0:13:23.350
variables, we can
make such a distinction

0:13:23.350,0:13:27.700
even if we have unknowns
there and therefore cannot calculate concretely.

0:13:28.210,0:13:32.230
That is the purpose of this
kind of static information for operations.

0:13:36.880,0:13:40.090
Now it
is like this:

0:13:40.090,0:13:44.740
For these arithmetic operations you would perhaps
think: Yes, what do we gain here?

0:13:44.740,0:13:45.550
That's just
school arithmetic.

0:13:45.550,0:13:51.430
We know what it means to
have a zero in division, for example.

0:13:51.430,0:13:52.240
That this
is a problem.

0:13:52.240,0:13:56.290
But the point is, this
handling of such arithmetic expressions,

0:13:56.290,0:13:58.060
or terms as they
are called, is more general.

0:13:58.060,0:14:05.170
While you know this from school, also worked
with such terms and transformed them, it is interesting

0:14:05.170,0:14:10.278
from a modeling point of view that
such an algebraic approach (i.e. to describe

0:14:10.278,0:14:19.060
the operations via their signatures, via input and
output, formats and the rules according to which terms

0:14:19.060,0:14:23.860
are then set up) is just not
only possible for arithmetic operations on numbers.

0:14:23.860,0:14:27.760
But in general, for operations
in practically any other application

0:14:27.760,0:14:33.070
domains, one has to deal with other sets
and other operation names and with new questions

0:14:33.070,0:14:35.410
about which combinations
should be allowed.

0:14:35.410,0:14:40.450
If you model this precisely, then you
have already recorded certain information about the

0:14:40.450,0:14:48.250
respective application domain before you
somehow start to implement something.

0:14:48.250,0:14:56.200
That should be the goal
here when specifying such operations.

0:14:56.200,0:14:59.320
Now I'll do an example, and
a different example than the arithmetic operations.

0:14:59.320,0:15:06.340
So let's imagine as another domain
that we want to do vector graphics.

0:15:06.340,0:15:09.490
So maybe we would like
to develop a graphics program or

0:15:10.390,0:15:16.330
somehow an app that should have
operations to draw and manipulate images.

0:15:16.330,0:15:18.730
And we want to
model that program now.

0:15:18.730,0:15:22.450
That means we're still
going to have numbers, but

0:15:22.450,0:15:25.990
we're now not *just* dealing with mathematical
number domains like we just did, but

0:15:25.990,0:15:30.750
we have to work with
other domain-specific types as well.

0:15:30.750,0:15:36.550
So for number domains we could now
take mathematical notation like we just did.

0:15:42.640,0:15:44.230
Maybe you learn parallel
in the GPT lecture

0:15:44.230,0:15:49.750
(depending on the course of
studies) the programming language Python.

0:15:49.750,0:15:55.000
There are also special
data types, for example the

0:15:55.000,0:16:01.840
number types for integers and for
floating point numbers, i.e. decimal numbers.

0:16:01.840,0:16:06.220
Maybe also strings, because you want
to have the output in text form.

0:16:06.220,0:16:10.630
And now here we would want
to introduce just more domain-specific types

0:16:10.630,0:16:13.090
that are not necessarily
in the programming language,

0:16:13.090,0:16:17.350
but that we need to
support our vector graphics domain.

0:16:17.350,0:16:19.330
So what do we
need in the graphics domain?

0:16:19.330,0:16:24.190
Colors perhaps, points, coordinates,
or even whole images.

0:16:27.520,0:16:30.040
So, let's think
about an initial operation.

0:16:30.040,0:16:34.000
What might we have as
an operation that creates an image?

0:16:34.000,0:16:38.140
Maybe we would like to be able
to paint a circle as an image.

0:16:38.140,0:16:39.490
And then we
need to think about:

0:16:39.490,0:16:41.350
What parameters
does that need?

0:16:41.350,0:16:42.370
At least
a radius.

0:16:42.370,0:16:44.575
We could also
say, maybe a color.

0:16:44.575,0:16:45.310
But we
could also say:

0:16:45.310,0:16:49.690
First of all, a circle in itself is simply
specified by the fact that there is a radius.

0:16:49.690,0:16:51.670
And that could also
be a decimal number.

0:16:51.670,0:16:55.870
That's why we introduce an operation
called "circle", takes a number, interprets

0:16:55.870,0:16:59.080
that number as a
radius, and returns an image.

0:17:01.150,0:17:04.930
We could imagine that if we
call "circle" as an operation with the

0:17:04.930,0:17:07.840
argument 3, then this
picture should be created.

0:17:07.840,0:17:11.590
I will now always show
such pictures here on the right,

0:17:11.590,0:17:16.440
as an idea of
what the operations should do.

0:17:16.440,0:17:22.410
But the modeling itself
does not contain this information.

0:17:22.410,0:17:22.830
Here it is
only about that:

0:17:22.830,0:17:26.460
There is this "circle" operation, which
takes a number and delivers an image.

0:17:26.460,0:17:31.380
The fact that it is this image in the concrete
case would no longer be part of the static modeling,

0:17:31.380,0:17:33.390
but already of
the dynamic modeling.

0:17:33.390,0:17:35.820
But maybe this helps
a little bit to

0:17:35.820,0:17:37.560
understand what I
want with the operation.

0:17:42.540,0:17:47.550
Although I will always show such examples,
the focus is actually on these operation

0:17:47.550,0:17:51.690
names and their signatures
(information about inputs and outputs).

0:17:54.660,0:18:02.430
Here it should be noted that 3
is of course an integer and not a

0:18:02.430,0:18:06.030
comma, but nevertheless may be used here,
too, if comma numbers are allowed here.

0:18:06.030,0:18:11.220
Because in the end the set of decimal
numbers is a superset of the set of integers.

0:18:11.220,0:18:13.740
So every integer is of
course also a "decimal number".

0:18:13.740,0:18:18.690
So you don't have to write
3.0 here, you can take 3 directly.

0:18:18.690,0:18:22.500
At least that's how I write
it down now in my example domain.

0:18:29.280,0:18:30.240
That would be
a first operation.

0:18:30.240,0:18:32.040
This alone would
not be super exciting.

0:18:32.040,0:18:35.070
You could paint exactly circles,
or always exactly one circle.

0:18:35.070,0:18:35.640
This is
then a picture.

0:18:35.640,0:18:40.290
Of course, we don't want to leave it
at that, we want to somehow provide for

0:18:40.290,0:18:44.340
a few more operations when
we design our vector graphics app.

0:18:44.340,0:18:48.600
And for example, we could start
to simply allow different geometric shapes.

0:18:48.600,0:18:51.810
For example, you want to
be able to draw a rectangle.

0:18:51.810,0:18:52.770
You'd have
to think about:

0:18:52.770,0:18:53.910
What are the
parameters for that?

0:18:53.910,0:18:55.470
There would have
to be two now.

0:18:55.470,0:18:57.930
There is no radius, but
perhaps a width and a height.

0:18:57.930,0:19:00.360
And the result
is again a picture.

0:19:00.360,0:19:06.450
The interpretation would be that if I
for example call "rectangle" with 7 and 5,

0:19:06.450,0:19:08.130
I get
such a rectangle.

0:19:08.130,0:19:14.280
There is already an interpretation in there,
namely that the first argument should be interpreted

0:19:14.280,0:19:18.090
as the width and the
second argument as the height.

0:19:18.090,0:19:21.270
That is not
in this specification here.

0:19:21.270,0:19:23.580
As static information
it only contains:

0:19:23.580,0:19:26.310
There are two
floating point arguments.

0:19:26.310,0:19:29.820
And not how they exactly contribute
to the picture in the end.

0:19:29.820,0:19:40.320
What one could also ask here, in
the sense of the arithmetic example domain before:

0:19:40.320,0:19:42.630
What happens if one
of the arguments is zero?

0:19:42.630,0:19:44.640
So already with the
circle, one might ask:

0:19:44.640,0:19:51.810
What if the circle is called with
the argument zero or even with negative radii?

0:19:51.810,0:19:57.990
This could have been countered
by deliberately introducing another set with

0:19:57.990,0:20:02.610
only non-negative
floating point numbers.

0:20:03.240,0:20:06.420
Or one would then make
decisions in the implementation how

0:20:06.420,0:20:08.460
to deal with
such edge cases.

0:20:08.460,0:20:09.120
So
maybe:

0:20:09.120,0:20:12.240
A "circle" of size zero
would simply be a point.

0:20:12.240,0:20:18.660
A rectangle of height zero
would simply be a horizontal line.

0:20:18.660,0:20:22.290
And for example for
negative arguments either always say

0:20:22.290,0:20:24.990
they are not accepted, or
they are treated like zero.

0:20:26.430,0:20:28.230
That is
not expressed here.

0:20:28.230,0:20:33.870
Here we are first concerned with what combinations
are allowed in principle, syntactically so to speak.

0:20:35.730,0:20:36.960
A few
more examples.

0:20:36.960,0:20:38.580
What could
be further operations?

0:20:38.580,0:20:41.310
One could
introduce another square.

0:20:41.310,0:20:44.640
Maybe you don't need it, because you
can represent a square as a rectangle.

0:20:46.020,0:20:49.290
But it might
become other general operations.

0:20:49.290,0:20:54.420
For example, you might want to
draw general paths, that is, any sequences

0:20:54.420,0:20:59.040
of strokes that don't exactly
make a box like this rectangle.

0:20:59.040,0:21:01.650
What do you
need as arguments?

0:21:01.650,0:21:03.930
Some kind of
coordinates, i.e. points.

0:21:03.930,0:21:08.130
A point as a combination
of x and y values.

0:21:08.130,0:21:10.200
And for a path
you need several points.

0:21:10.200,0:21:14.400
So maybe a list like that, a
listing of several pairs of coordinates like that.

0:21:14.400,0:21:16.470
You
could say:

0:21:19.440,0:21:21.270
A path has
as argument a list.

0:21:21.270,0:21:25.230
This is now to be
indicated here by these square brackets.

0:21:25.230,0:21:28.770
And in this list
coordinate pairs can stand.

0:21:28.770,0:21:35.350
So (-1,0) would be the first point here, x-axis
-1, y-axis 0, and the next point would be here.

0:21:35.350,0:21:36.940
So behind
the point, point,

0:21:36.940,0:21:41.140
point would be hiding other
such pairs, for example (1,2).

0:21:42.160,0:21:46.060
Here there seems to be
(3,0) and then here (6,4).

0:21:46.060,0:21:51.880
So I call the path operation
with such a list of coordinate pairs,

0:21:51.880,0:21:53.290
and then an
image comes out.

0:21:53.290,0:21:55.480
In that case
just this zigzag curve.

0:21:58.720,0:22:01.240
And maybe also
as another operation:

0:22:01.240,0:22:05.560
Suppose we also want to allow
labels in our images, text somehow.

0:22:05.560,0:22:08.860
Then we have to have an
operation that converts text into an image.

0:22:08.860,0:22:11.470
And that could be,
for example, simply like this:

0:22:11.470,0:22:13.540
The name "print"
might be quite obvious.

0:22:13.540,0:22:17.020
And the argument to that operation
would be a string, a text.

0:22:17.020,0:22:21.160
And the result would be
an image representing that text.

0:22:21.160,0:22:23.530
So for
example print("ABC").

0:22:25.090,0:22:28.930
You probably know these quotation marks
as well, as delimiters for strings

0:22:28.930,0:22:33.550
in many programming languages (or in
the programming language you learn first).

0:22:33.550,0:22:38.530
And then the result here will be
an image that contains exactly the text ABC.

0:22:41.800,0:22:44.110
So, we could do a
few things with that now.

0:22:44.110,0:22:48.940
Strictly speaking, we could either draw
a circle, or draw a rectangle,

0:22:48.940,0:22:55.930
or draw any sequence of strokes
like that, or output a string.

0:22:57.100,0:23:00.010
Now we would like
to have more flexibility.

0:23:00.010,0:23:02.800
For example, this string
here is very small now.

0:23:02.800,0:23:06.010
Maybe you'd rather
have it displayed larger.

0:23:06.010,0:23:13.300
We have designed the print operation in such a way
that it does not specify (as an argument, for example)

0:23:13.300,0:23:17.860
what font size you
want to print this with.

0:23:17.860,0:23:20.710
We could revise
that and say:

0:23:20.710,0:23:22.270
We introduce
an argument here.

0:23:22.270,0:23:23.710
Then we still
wouldn't have the

0:23:23.710,0:23:27.430
ability to resize other
graphical objects, for example.

0:23:27.430,0:23:29.590
So more generally, perhaps,
would be to say:

0:23:30.730,0:23:36.130
Outputting a string is always
done in some fixed font size.

0:23:36.670,0:23:40.060
But if we want
a string to be displayed

0:23:40.060,0:23:42.970
larger, there is another operation for
that, which can enlarge any image.

0:23:42.970,0:23:46.030
Including also images
created by "print".

0:23:46.030,0:23:52.480
If we decide this way, it
would mean that we would introduce an

0:23:52.480,0:23:56.140
operation (and even several
operations) to manipulate existing figures.

0:23:56.140,0:24:01.990
In the operations we have seen so
far, Picture only ever appeared as a result.

0:24:01.990,0:24:04.210
We put a number in, get a picture.
We plug in two numbers, get a picture.

0:24:06.850,0:24:10.120
We plug in a list
of points, we get a picture.

0:24:10.120,0:24:13.750
We put in a
string, we get a picture.

0:24:13.750,0:24:15.220
If we want
to go beyond

0:24:15.220,0:24:18.580
that, we could provide operations that
have images as input as well.

0:24:18.580,0:24:23.410
And for example, for this
scaling, for resizing, we could say:

0:24:23.410,0:24:27.670
We'd like to have
an operation called scale.

0:24:27.670,0:24:35.440
It gets an image, gets two
numbers to be interpreted as scale.

0:24:35.440,0:24:38.522
Enlargement or reduction, depending on whether it
is greater than 1 or less than 1.

0:24:38.522,0:24:42.370
So it should be one
factor each, in x- and y-direction.

0:24:42.370,0:24:42.790
Then we
could say:

0:24:42.790,0:24:46.870
Well, if we take the picture, which
results from print("ABC") (that would be this

0:24:46.870,0:24:52.600
small picture here), and we scale that by the
factor 3 in both x and y direction, then

0:24:52.600,0:24:56.710
we get evenly
this larger ABC typeface.

0:25:00.010,0:25:02.800
That would be one
way of manipulating existing figures.

0:25:02.800,0:25:03.811
We can
think of others.

0:25:03.811,0:25:07.090
For example, if we want
to color the text as

0:25:07.090,0:25:12.160
well, or color other figures, maybe
a "color" operation would be good.

0:25:12.160,0:25:17.260
It has to get an image again, and
it has to get a color passed to it.

0:25:17.260,0:25:20.770
So there has to be
a supply of colors somehow.

0:25:20.770,0:25:23.530
That's just a new set
that would be defined somewhere.

0:25:23.530,0:25:26.380
And the result would
be an image again.

0:25:26.380,0:25:28.240
And then we
could say, for example:

0:25:28.240,0:25:31.750
Take the image from just
now (even before scaling, that

0:25:31.750,0:25:34.690
is, the little string
"ABC"), and color it red.

0:25:34.690,0:25:36.880
Then you
get this result.

0:25:36.880,0:25:40.000
And wanted would be
of course, if we

0:25:40.000,0:25:44.200
combine this, call both "scale"
and "color" (use nested operations),

0:25:44.200,0:25:47.990
then we should get
the big string in red.

0:25:47.990,0:25:50.300
The idea then is to
get an image out of here

0:25:50.300,0:25:52.370
that can be used again
as an argument to this.

0:25:53.420,0:25:55.940
We could of course combine these
operations, just as in arithmetic we can

0:25:56.690,0:26:00.290
put "plus" and "times" and
"division" etc. into each other.

0:26:00.290,0:26:06.410
And get bigger and bigger expressions, which
are more complicated, but can be calculated out

0:26:06.410,0:26:10.850
with the definitions of the single
operations, by doing several calculation steps.

0:26:13.130,0:26:13.910
What else
can we want?

0:26:13.910,0:26:14.750
Scaling,
coloring.

0:26:14.750,0:26:16.460
Rotate,
for example.

0:26:17.210,0:26:21.710
Our rectangles earlier
were always axis-parallel.

0:26:21.710,0:26:24.170
Maybe we want to
have rectangles that are skewed.

0:26:24.170,0:26:27.770
Then we would have to have
the ability to rotate an image.

0:26:27.770,0:26:29.330
So we
could say:

0:26:29.330,0:26:31.910
Our rectangle from before, that
would be the expression "rectangle(7,5)".

0:26:32.780,0:26:34.580
We'd like to rotate
that by an angle.

0:26:34.580,0:26:38.420
Then we would have
to somehow capture, or

0:26:38.420,0:26:40.790
decide, how to
interpret that angle.

0:26:40.790,0:26:45.530
Let's assume we measure angles simply
in degrees and not somehow in radians.

0:26:45.530,0:26:52.910
Then 30 just corresponds to a
rectangle tilted about this angle here, with

0:26:52.910,0:26:56.000
the rotation always taking
place about the origin.

0:26:56.000,0:27:04.100
So, what can
we do now?

0:27:04.100,0:27:09.140
Now we have these images that
we can change a little bit.

0:27:09.140,0:27:11.900
But they're always
centered around the origin.

0:27:11.900,0:27:15.440
Which also means, for example, that rotating
a circle makes no sense at all.

0:27:15.440,0:27:21.320
Because the circle was
formed around the origin.

0:27:21.320,0:27:24.650
If we rotate it now, and
this always happens around the origin,

0:27:25.190,0:27:28.940
one could do nothing else with the
circle than paint it and color it.

0:27:31.610,0:27:33.920
You could scale it and
make it an ellipse by

0:27:33.920,0:27:35.630
scaling it differently
in x- and y-direction.

0:27:35.630,0:27:38.750
But you can't, for example, draw
it in any other place than

0:27:38.750,0:27:41.180
the origin of
the coordinate system.

0:27:41.180,0:27:46.070
This is certainly unattractive
for a general graphics app.

0:27:46.070,0:27:50.180
So we should have at least
one more operation that allows us

0:27:50.180,0:27:55.580
to draw objects at some
place other than the origin.

0:27:55.580,0:28:01.040
And if we would also let all
strings we want to print always overlap at

0:28:01.040,0:28:03.230
the origin, we wouldn't be
able to read anything at all.

0:28:03.230,0:28:05.690
So, what do
we need for this?

0:28:05.690,0:28:08.060
Another operation to
move an image.

0:28:08.060,0:28:09.890
What does it
need for arguments?

0:28:10.850,0:28:14.690
First, the image to be moved,
and then probably two parameters again.

0:28:14.690,0:28:19.040
Like here for x- and y-direction,
but just not as scaling factors, but

0:28:19.040,0:28:21.410
as
displacement values.

0:28:21.410,0:28:26.000
And the result would
be an image, of course.

0:28:26.000,0:28:27.080
So the
idea is:

0:28:27.080,0:28:31.850
If we take a circle of
radius 3 and shift it in

0:28:31.850,0:28:36.080
x-direction by 2 and in y-direction
by 1, we get the same shape,

0:28:36.080,0:28:39.650
the same circle, but it
is now in a different position.

0:28:42.020,0:28:43.400
And the circle
is then completely shifted,

0:28:43.400,0:28:48.410
which is why the center would
now be at this new position (2,1).

0:28:52.160,0:29:01.720
Then we could draw individual
shapes of our choice, our

0:29:01.720,0:29:06.760
size, our color,
our choice of position.

0:29:06.760,0:29:08.770
However, we could not
combine any of these.

0:29:08.770,0:29:13.330
For example, we could not yet
draw an image containing both a circle

0:29:13.330,0:29:15.610
and a rectangle
in this way.

0:29:15.610,0:29:19.960
With the operations we have so far,
we would only ever be able to

0:29:19.960,0:29:25.780
paint single geometric shapes
and position them somewhere.

0:29:25.780,0:29:27.580
So, what else
would we need?

0:29:27.580,0:29:30.370
What else would be conceivable
or desirable as a meaningful operation?

0:29:30.370,0:29:33.190
Anything that would allow
us to combine multiple images.

0:29:33.190,0:29:37.810
And the easiest choice would
be to introduce a binary

0:29:37.810,0:29:42.040
operation, like the "plus" in numbers ("+"
takes two numbers and returns one number).

0:29:42.040,0:29:43.690
We've only ever
had operations now

0:29:43.690,0:29:46.360
that took at most one
image and returned one image.

0:29:46.360,0:29:49.540
If we want to
combine images, maybe overlap

0:29:49.540,0:29:54.790
them, we need an operation that
composes an image from partial images.

0:29:54.790,0:29:57.400
This could be a
binary operation with two arguments,

0:29:57.400,0:30:00.640
each Pictures, and it
should return a Picture.

0:30:00.640,0:30:06.190
What would be a
reasonable use for it?

0:30:06.190,0:30:10.630
For example, we could
form the following expression:

0:30:10.630,0:30:14.320
So somehow a path,
which we have seen before.

0:30:14.320,0:30:16.450
We color
it blue.

0:30:16.450,0:30:18.310
Because we may
combine the operations.

0:30:18.310,0:30:20.830
That would be
a picture expression.

0:30:20.830,0:30:26.290
And we get another image expression by
outputting a piece of text, coloring it, rotating

0:30:26.290,0:30:31.450
it appropriately, and somehow moving it
from the origin to a different location.

0:30:31.450,0:30:35.290
And then we would have an image that
corresponds to this blue zigzag line, and an

0:30:35.290,0:30:39.520
image that corresponds to
this cleverly positioned text.

0:30:39.520,0:30:44.680
And if we combine that with this
new operation, then we get an image that

0:30:44.680,0:30:45.640
has both
in it.

0:30:45.640,0:30:49.870
And now, with these ingredients and
the arbitrary nesting of operations (as we're

0:30:49.870,0:30:56.830
already seeing here), we could already
create quite complex and interesting images.

0:31:00.540,0:31:02.910
One thing to
note is that

0:31:02.910,0:31:06.810
this new operation is now
used as an infix operation.

0:31:06.810,0:31:09.390
That is, unlike "move"
and "color" etc, it is

0:31:09.390,0:31:12.000
no longer used with
parentheses around its arguments.

0:31:12.000,0:31:14.430
Instead, you simply write
them between two terms.

0:31:14.430,0:31:16.500
Just as you are
used to from mathematics, from

0:31:16.500,0:31:20.209
arithmetic, that the "plus" is
simply infixed between two numbers.

0:31:20.209,0:31:24.150
So infix in the sense of
"between the operands", between the arguments.

0:31:24.150,0:31:27.990
Instead of as in "move", "rotate", etc.,
that you write the arguments in parentheses.

0:31:27.990,0:31:33.330
This is a common usage,
especially of such symbol operations.

0:31:33.330,0:31:35.580
In doing so, one
can also ask oneself:

0:31:35.580,0:31:38.880
For example, can I apply
the operation to three images?

0:31:38.880,0:31:41.940
Probably not directly, because here
it says: there are two images.

0:31:41.940,0:31:45.360
But like I can write down
"plus": 2 + 5 + 4.

0:31:45.360,0:31:49.260
Then I have added three numbers,
although "plus" is a binary operation.

0:31:49.260,0:31:51.720
But again, could I combine more
than two pictures by simply writing: this

0:31:51.720,0:32:01.890
picture, operation symbol, next picture,
operation symbol, next picture again, etc.?

0:32:01.890,0:32:05.970
For the Komedia students, for
example, as a reminder of

0:32:05.970,0:32:09.120
the Mathematical Structures
lecture, there we

0:32:09.120,0:32:11.280
had considered monoids, that was
about associative operations in algebra.

0:32:11.280,0:32:14.970
Here you would expect that
to be such an associative operation.

0:32:14.970,0:32:17.910
The other
students certainly know

0:32:17.910,0:32:20.640
associativity at least as a
property of "plus" or "times".

0:32:20.640,0:32:25.980
So then it's okay to use
this operation symbol even if we

0:32:25.980,0:32:29.670
want to combine more than
two pictures in a row.

0:32:29.670,0:32:40.060
So, now I just designed
some operations and showed some examples.

0:32:40.060,0:32:45.070
Of course I won't do an implementation of
them now, that's not what this is about.

0:32:45.070,0:32:50.470
But what is interesting and important here,
and why we introduce this, is that

0:32:50.470,0:32:55.930
we can recognize certain calls/combinations
of operations as useful or

0:32:55.930,0:32:58.060
not useful based
on such static information.

0:32:58.060,0:32:59.830
That's the aspect
I mentioned before.

0:32:59.830,0:33:02.350
That such static
information can serve to

0:33:02.350,0:33:08.080
exclude certain potential errors ultimately
already in the modeling, so

0:33:08.080,0:33:10.240
that they can no
longer occur in the implementation.

0:33:11.170,0:33:14.650
Typical examples would
be the following:

0:33:14.650,0:33:17.830
For example, it makes
no sense for the

0:33:17.830,0:33:22.900
operation introduced by me to
write something like "circle-of-circle-3" here.

0:33:22.900,0:33:25.330
So "circle(3)" is
a meaningful expression.

0:33:25.330,0:33:30.700
We even saw then earlier the
picture that emerges when I interpret that.

0:33:30.700,0:33:35.530
But it doesn't make sense to
write "circle" again because of that.

0:33:36.190,0:33:36.970
Why
not?

0:33:36.970,0:33:45.190
Because "circle", according to the signature I had at the
front of the slide, expects a number as an argument.

0:33:45.190,0:33:49.390
Which is true
here for this expression.

0:33:49.390,0:33:56.050
But for the outer call, the argument
is not a number, but an image.

0:33:56.050,0:34:00.040
Because 3 is a
number, "circle-of-3" is then a

0:34:00.040,0:34:03.550
picture, and I can't put a
picture as an argument into "circle".

0:34:04.420,0:34:07.420
That would be the argument here
why this expression would not be okay.

0:34:07.420,0:34:11.020
Why that's rejected, just
based on the static information.

0:34:11.020,0:34:15.580
In the implementation, if we use
a programming language that takes into

0:34:15.580,0:34:20.440
account such signatures of operations, we would
expect an error message from the compiler.

0:34:20.440,0:34:21.130
That
it says:

0:34:21.130,0:34:23.260
This expression makes no
sense, I refuse to

0:34:23.260,0:34:27.520
even create a program for
it, which would then be executable.

0:34:27.520,0:34:37.860
And you can think of various other cases
that are okay and that are not okay.

0:34:37.860,0:34:41.520
On the slide, I've listed a
few cases that are not okay.

0:34:41.520,0:34:46.620
Each with a short intuitive explanation
why this expression would not be okay.

0:34:46.620,0:34:48.000
This expression would
not be okay

0:34:48.000,0:34:52.710
because "circle(3)" is again an image,
and that itself is not printable text.

0:34:52.710,0:34:55.710
So "print"
expects a string,

0:34:55.710,0:34:58.950
a string like text, which
is then converted to an image.

0:34:58.950,0:35:02.010
I can't pass "print"
an already finished image.

0:35:02.010,0:35:03.930
Then "print" would not
know what to print.

0:35:03.930,0:35:07.410
It would not,
as the operations are

0:35:07.410,0:35:10.320
interpreted here, print
somehow the text "circle(3)".

0:35:10.320,0:35:12.540
For that, it would have
to be enclosed in quotation marks.

0:35:12.540,0:35:16.530
Yes, "print" can print any text, but
it would have to be clear somehow,

0:35:16.530,0:35:19.800
by quotation marks, that
you really have a

0:35:19.800,0:35:23.820
string there and not another expression
to be interpreted as an image.

0:35:27.780,0:35:31.530
For the same reasons, something
like "print-from-3" would not be okay,

0:35:31.530,0:35:32.880
at least
in my interpretation.

0:35:33.480,0:35:38.970
There are programming languages where here, if
there is a 3, it would just

0:35:38.970,0:35:42.540
be silently implemented
as the string "3".

0:35:42.540,0:35:45.420
I don't want
to allow that here.

0:35:45.420,0:35:51.150
I had imagined strings
and numbers as different

0:35:51.150,0:35:54.750
things, respectively
named them differently.

0:35:55.320,0:36:01.050
That is, "print-from-3" would not be a
valid expression here in my example domain

0:36:01.050,0:36:05.280
now, because it is not true that
the 3 is a string by itself.

0:36:05.280,0:36:08.040
For that, it would have
to be enclosed in quotation marks.

0:36:09.870,0:36:13.560
And for none of these observations
here do I have to somehow run

0:36:13.560,0:36:16.230
the program and paint the
things, that is, somehow create images.

0:36:16.230,0:36:19.170
I can already determine all
that from the static information.

0:36:19.170,0:36:22.530
Here's
another mistake.

0:36:22.530,0:36:25.800
Here's the error: we applied
"print" to a string, an

0:36:25.800,0:36:28.680
image comes out, here I'd like
to scale by a factor of 3.

0:36:28.680,0:36:30.900
Why is
this still wrong?

0:36:30.900,0:36:32.760
Because this has the
wrong number of arguments.

0:36:32.760,0:36:33.450
I introduced
in front:

0:36:33.450,0:36:36.870
"scale" always takes two arguments in addition
to the image, i.e. two numbers, to

0:36:36.870,0:36:39.240
be able to scale
in x and y directions.

0:36:39.240,0:36:40.800
If I
forget one of

0:36:40.800,0:36:44.250
them, I would expect that
to be a non-valid expression here.

0:36:44.250,0:36:48.490
So even if you only want
one factor to scale, you have to

0:36:48.490,0:36:52.540
specify it twice to use it
for both x and y directions.

0:36:52.540,0:36:58.900
For coloring, there we need an
image and a color to color.

0:36:58.900,0:37:01.411
But specified
it was as:

0:37:01.411,0:37:03.490
You specify the image
first and then the color.

0:37:03.490,0:37:07.360
And if I do that the wrong way around,
I would expect that to be rejected here as well.

0:37:14.620,0:37:18.970
Again, more of an
error of the sort above.

0:37:18.970,0:37:23.740
So "rotate" expects an
image and an angle,

0:37:23.740,0:37:27.910
rather than two angles or
anything that is a number.

0:37:27.910,0:37:33.670
Here in front there should be an image,
and the number 30 itself is not an image.

0:37:33.670,0:37:38.890
You can print 30 with "print(30)", then you
would have an image that you could rotate.

0:37:38.890,0:37:45.520
But the number 30 itself is not
an image and therefore cannot be rotated.

0:37:45.520,0:37:48.610
Our combination operator, that
was meant for images.

0:37:48.610,0:37:54.190
So as rather said, the specification was
for a Picture and also a Picture, and

0:37:54.190,0:37:55.660
the result would
be a Picture.

0:37:55.660,0:38:00.430
For "ABC" and "DEF" you could imagine
that you want to pack them together somehow.

0:38:00.430,0:38:03.760
Maybe you want to
get the string "ABCDEF".

0:38:03.760,0:38:06.040
For this one would have
to introduce however another operation.

0:38:06.040,0:38:12.340
The operation "and" with this symbol
was introduced as operation between pictures.

0:38:12.340,0:38:17.935
And "ABC" as well as
"DEF" are just no pictures.

0:38:17.935,0:38:19.120
So we have a
whole set of errors,

0:38:19.120,0:38:25.660
which one could exclude, simply
by keeping to the operation signatures.

0:38:25.660,0:38:29.770
Conversely, of course, this does not mean
that all programming errors are automatically detectable.

0:38:29.770,0:38:34.480
So for instance with the
rectangle operation, the requirement was:

0:38:34.480,0:38:35.680
You have to
specify two numbers.

0:38:35.680,0:38:40.570
And I had interpreted the first number
as width and the second as height.

0:38:40.570,0:38:43.270
But of course,
this is not in

0:38:43.270,0:38:49.420
the signature, in this
specification on the corresponding slide.

0:38:49.420,0:38:52.090
Here, from this, you can't tell what
is the height and what is the width.

0:38:52.090,0:38:52.510
That
is:

0:38:52.510,0:39:00.820
Even if I actually want to
draw a wider than higher rectangle

0:39:00.820,0:39:05.440
like this, but accidentally
write "rectangle(5,7)" instead of "rectangle(7,5)",

0:39:05.440,0:39:10.930
that would be an error
that cannot be detected statically.

0:39:11.500,0:39:14.050
Because this role
of these two

0:39:14.620,0:39:19.570
arguments, it is not fixed by
the static information from the previous slides.

0:39:19.570,0:39:20.260
That
is:

0:39:20.260,0:39:24.010
An error that I make there is simply
an error that I would only notice dynamically at

0:39:24.010,0:39:27.580
runtime, at execution time
of my app / program.

0:39:27.580,0:39:32.200
But a whole series of
possible errors are already caught statically.

0:39:32.200,0:39:37.840
And depending on the programming language, more
or less of such errors are acceptable here,

0:39:37.840,0:39:42.160
of course, or are
waved through, so to speak.

0:39:42.160,0:39:44.470
So in Python
"print(3)" would probably work.

0:39:44.470,0:39:45.520
That would
simply be interpreted.

0:39:45.520,0:39:49.270
In my domain here I had
specified that I don't want that.

0:39:49.270,0:39:52.840
So that there has
to be a string explicitly.

0:39:56.920,0:40:01.870
That's practically the
end of this part.

0:40:01.870,0:40:05.200
One little comment, one little
note, I would like to make.

0:40:05.200,0:40:11.770
And that is for those of you
who know programming languages like C or Java.

0:40:11.770,0:40:16.240
That's not necessarily the case for all of
you, because, for example, the programming introduction at our

0:40:16.240,0:40:20.650
school is now with Python,
for Komedia and Applied Computer Science.

0:40:20.650,0:40:24.340
But if you know C or
Java from school, for example, then on

0:40:24.340,0:40:30.190
the one hand you know the concept
of such operations, such specifications of signatures.

0:40:30.190,0:40:32.380
On the other hand, you
know a different syntax for it.

0:40:32.380,0:40:35.020
So there it is
not specified so mathematically.

0:40:35.020,0:40:39.400
Therefore, a small slide, where
simply this connection is made, how

0:40:39.400,0:40:42.340
this corresponds
to each other.

0:40:42.340,0:40:46.420
So this "rectangle" operation,
for example, which I

0:40:46.420,0:40:54.760
have defined or declared, is passed
two numbers and returns an image.

0:40:54.760,0:40:59.920
In C or Java, and many
other mostly object-oriented or simply imperative programming

0:40:59.920,0:41:01.900
languages, it
would correspond to

0:41:02.480,0:41:06.260
a declaration of the following kind
(if they are typed programming languages):

0:41:06.800,0:41:11.630
The name "rectangle" would be used
here as the name of a function.

0:41:14.780,0:41:18.860
The result type, i.e. what comes
out (which is the last quantity

0:41:18.860,0:41:24.980
here in mathematical notation),
is then often specified first.

0:41:24.980,0:41:29.600
So "rectangle" returns an image and
gets the arguments passed to it,

0:41:29.600,0:41:32.570
which are here to
the left of the arrow.

0:41:32.570,0:41:38.600
So here would be that
two floating point numbers are passed.

0:41:38.600,0:41:40.490
And often a
name for the

0:41:40.490,0:41:43.490
parameters is given directly
in the programming language.

0:41:43.490,0:41:47.780
This provides a little bit
more information, if x and

0:41:47.780,0:41:51.290
y are interpreted geometrically as
the x and y coordinates.

0:41:51.290,0:41:53.090
There could be
arbitrary names for

0:41:53.090,0:41:56.750
it, but there of course names
are assigned gladly, which already say something

0:41:56.750,0:42:01.640
about the intention of the operation
and the use of the arguments.

0:42:03.710,0:42:06.860
So this is
noted here simply because

0:42:06.860,0:42:11.570
many of you may
know this kind of notation.

0:42:11.570,0:42:16.700
And then you should just be able to match it
very directly to how I just declared the operations here

0:42:16.700,0:42:23.465
now in the slides, and how it's going
to happen in the corresponding exercise as well.

0:42:23.465,0:42:26.840
So that's almost the same
information, just written down differently.
