0:00:01.860,0:00:04.200
Let's move on to
the chapter on statecharts.

0:00:04.200,0:00:07.350
Especially
UML statecharts.

0:00:07.350,0:00:14.610
We had already seen flat state diagrams
at the very beginning of the lecture.

0:00:14.610,0:00:22.950
And these UML state diagrams
(state machine diagrams/statecharts) are in

0:00:23.610,0:00:29.040
principle closely related to the flat
state diagrams we have already seen.

0:00:29.040,0:00:35.160
But in particular they
offer further structuring possibilities, which

0:00:35.160,0:00:36.360
we will get to
know in a moment.

0:00:36.360,0:00:38.970
Concerning
usage.

0:00:38.970,0:00:45.630
Statecharts are
used when the

0:00:45.630,0:00:49.890
focus of modeling is on
states and transitions between them.

0:00:49.890,0:00:52.800
So a bit away
from what activity diagrams do.

0:00:53.460,0:00:58.440
In a way also the Petri
nets namely to aim at action sequences.

0:00:58.440,0:01:00.870
So putting the
actions in the foreground.

0:01:00.870,0:01:05.010
This is more about states and
state transitions of a given system.

0:01:05.010,0:01:09.060
In a way,
UML state diagrams are

0:01:09.060,0:01:11.220
rather used when there
is no typical sequence.

0:01:11.220,0:01:17.520
Rather, the focus is on
sequences and events that occur randomly

0:01:17.520,0:01:22.800
or are equally likely
to occur in any order.

0:01:22.800,0:01:24.210
This is not to say
that there are not systems that

0:01:24.210,0:01:26.250
can usefully be
modeled with Petri

0:01:28.080,0:01:31.680
nets/activity diagrams as well as
flat or UML state diagrams.

0:01:31.680,0:01:33.840
These are all
possibilities for dynamic modeling.

0:01:33.840,0:01:37.440
And there are certainly examples
where one would have a choice.

0:01:37.440,0:01:44.250
But there are also cases where one
of the two rough directions is more appropriate.

0:01:48.510,0:01:55.380
To distinguish between the two, I would
like to make this observation that activity diagrams

0:01:55.380,0:02:03.240
focus on actions and state diagrams
focus on reactions to the environment.

0:02:03.240,0:02:06.300
So a state transition is
triggered by something from outside.

0:02:06.300,0:02:09.660
And then it has to be
described what that does to the states,

0:02:09.660,0:02:12.660
or what new state is
then taken by the system.

0:02:12.660,0:02:16.800
Instead of simply putting sequences
of actions in the center.

0:02:19.560,0:02:20.880
That's very
abstract at first.

0:02:20.880,0:02:24.570
Concretely, of course, one
can find various applications.

0:02:24.570,0:02:26.640
I have only
mentioned a few.

0:02:26.640,0:02:33.630
State diagrams, whether flat
or UML state diagrams with

0:02:34.170,0:02:42.240
additional elements and representation options,
are used in various application domains.

0:02:42.240,0:02:44.400
When
describing protocols.

0:02:44.400,0:02:45.900
Components of
distributed systems.

0:02:45.900,0:02:50.160
The description of
processes in user interfaces.

0:02:50.160,0:02:52.230
Embedded
systems.

0:02:52.230,0:02:56.070
One can certainly
continue the list long.

0:02:56.070,0:03:01.500
Because states and transitions have
become a very general framework

0:03:01.500,0:03:06.480
to describe behavior in computer
science, but also in other domains.

0:03:06.480,0:03:08.760
Specifically,
the

0:03:08.760,0:03:14.250
state diagrams/statecharts as they later entered
UML date back to the late 80s.

0:03:14.250,0:03:16.605
By a scientist
named David Harel.

0:03:16.605,0:03:18.660
The original
name was statecharts.

0:03:18.660,0:03:24.420
That's why you still find that as
the name when you look for examples.

0:03:24.420,0:03:29.550
At the beginning of the
slides, in the first or second

0:03:29.550,0:03:34.020
week, I had given
an article by Mr. Harel.

0:03:34.020,0:03:38.130
That is the original
paper where statecharts were introduced.

0:03:38.130,0:03:42.510
And with about different
syntax, they later entered UML.

0:03:42.510,0:03:50.130
A major goal
of UML statecharts/statecharts is

0:03:50.130,0:03:51.960
what can happen
in flat statecharts.

0:03:51.960,0:03:56.032
Namely, to get a handle on the
fact that the state space grows a lot.

0:03:56.032,0:03:59.790
There are simply certain features
that statecharts are equipped with.

0:03:59.790,0:04:02.970
In addition to simply
states and state transitions,

0:04:02.970,0:04:08.640
which already existed in flat statecharts,
there are, for example, refinements of states.

0:04:08.640,0:04:13.170
States are not just nodes
in a graph, without internal structure.

0:04:13.170,0:04:14.850
But they can
be refined hierarchically.

0:04:14.850,0:04:22.020
And that also leads to being
able to handle a state explosion.

0:04:23.610,0:04:26.790
In addition, there is
an explicit concept of parallelism.

0:04:26.790,0:04:28.860
We have already learned
about this in various places.

0:04:28.860,0:04:31.830
In Petri
nets/activity diagrams.

0:04:31.830,0:04:36.150
That it's important to be able to express
that; or interesting to be able to model that.

0:04:36.150,0:04:40.800
In statecharts (UML and statecharts)
there is an explicit concept

0:04:40.800,0:04:45.300
here for what is
called parallel switching through regions.

0:04:45.300,0:04:50.730
Which a flat statechart does
not allow to express explicitly.

0:04:50.730,0:04:55.170
And also this will lead
us to model more compactly

0:04:55.170,0:04:57.990
in UML statecharts
than with flat statecharts.

0:04:57.990,0:05:04.080
A related feature, which
ultimately makes it easier

0:05:04.080,0:05:09.420
or possible to deal with
these two aspects, is history nodes.

0:05:09.420,0:05:11.689
I haven't had much to
say about that yet either.

0:05:11.689,0:05:14.010
We'll see when we get
that far in the example.

0:05:14.010,0:05:18.180
The main point is to
be able to remember implicitly which

0:05:18.180,0:05:19.620

states

0:05:20.700,0:05:26.940
were active last, especially
when leaving such hierarchical/nested/parallel states.

0:05:26.940,0:05:31.350
In order to be able
to resume work later when returning

0:05:31.350,0:05:37.140
to such a hierarchical/parallel connected
area of the state diagram.

0:05:37.140,0:05:40.890
Instead of having to store
this explicitly in the states.

0:05:43.230,0:05:47.151
Then there are so-called
remote triggers, or flags.

0:05:47.151,0:05:51.450
These are simply means to
enable communication in the state diagram.

0:05:51.450,0:05:57.570
Even between states that are
not explicitly connected by a transition.

0:06:00.840,0:06:06.960
Many of these features are
mainly used to make diagrams that

0:06:06.960,0:06:10.200
we use
clear and compact.

0:06:10.200,0:06:13.680
So to avoid having to
have a lot of states.

0:06:13.680,0:06:16.350
Or if you have many states,
to group them in a meaningful way.

0:06:16.350,0:06:19.080
That the diagram
still remains clear.

0:06:19.080,0:06:25.470
So the goal is a size
reduction, versus using a flat state diagram.

0:06:26.320,0:06:30.700
What will not occur here that
we switch between finite and infinite.

0:06:30.700,0:06:34.810
We usually assume flat
statecharts to be finite.

0:06:34.810,0:06:39.670
And even a finite
UML state diagram will

0:06:39.670,0:06:43.570
not correspond to an
infinite flat state diagram.

0:06:43.570,0:06:44.350
This is different
from Petri nets.

0:06:44.980,0:06:48.490
An infinite Petri net can
have an infinite reachability graph.

0:06:48.490,0:06:52.060
We will not have this
transition from finite to infinite.

0:06:52.060,0:06:57.820
But a similar size reduction or
similar behavior, with respect to size.

0:06:57.820,0:07:00.670
Where even a very small
Petri net can still have a

0:07:00.670,0:07:03.760
very large
reachability graph.

0:07:04.870,0:07:05.560
So it will
be similar here.

0:07:05.560,0:07:09.640
There can be very
compact small UML state diagrams,

0:07:09.640,0:07:13.630
but they would correspond to
very large flat state diagrams.

0:07:16.480,0:07:22.900
We'll do most of the
discussion on a concrete example.

0:07:22.900,0:07:25.558
That's what I'm going
to design here now.

0:07:25.558,0:07:29.440
And first describe
what the goal is.

0:07:29.440,0:07:32.170
And then after that in other
videos we will gradually realize this

0:07:32.170,0:07:34.270
example as
UML state diagrams.

0:07:35.410,0:07:39.340
I didn't make up the example,
that also comes from Harel's article.

0:07:39.340,0:07:45.400
However, he discussed it in
more detail and with more properties.

0:07:45.400,0:07:48.340
This is a
simplified variant of the

0:07:48.340,0:07:51.580
example Harel used
to motivate his statecharts.

0:07:51.580,0:07:58.810
However, this also means that if you like,
you can read about it in the article.

0:08:01.060,0:08:02.890
It is supposed to
be about a wristwatch.

0:08:02.890,0:08:06.070
A very
simple wristwatch.

0:08:06.070,0:08:10.090
It has a display,
an alarm, and two buttons.

0:08:10.090,0:08:13.540
What should be
the intuition here?

0:08:13.540,0:08:14.800
This below is not
yet a state diagram.

0:08:14.800,0:08:17.800
I'm just giving
in a stylized

0:08:20.230,0:08:23.980
way how the wristwatch can
present itself, in certain situations.

0:08:23.980,0:08:25.600
And will have
arrows in between.

0:08:25.600,0:08:27.700
But it won't be
a UML state diagram yet.

0:08:27.700,0:08:28.720
Very
important!

0:08:28.720,0:08:29.980
So there
is this watch.

0:08:29.980,0:08:32.290
It has two buttons, a
and b, left and right.

0:08:32.290,0:08:33.850
And it
has two modes.

0:08:33.850,0:08:37.150
It can be in
a so-called time display mode.

0:08:37.150,0:08:40.780
Then we have just here
in the display the current time.

0:08:40.780,0:08:46.750
The hour and minute
hand, but digitally displayed.

0:08:46.750,0:08:50.290
Or it can be
in an alarm setting.

0:08:50.290,0:08:51.880
You can
set an alarm.

0:08:51.880,0:08:53.980
To do that, you first
have to switch to a display

0:08:53.980,0:08:56.050
mode, where you can see if
the alarm is on or off.

0:08:56.050,0:08:59.770
And then you can turn it on
and off with one of the buttons.

0:08:59.770,0:09:04.180
So switch between the
two on and off situations.

0:09:06.010,0:09:09.250
For switching, this
button a is meant.

0:09:09.250,0:09:12.130
So if we're in
the time display, we

0:09:12.130,0:09:15.700
can press the button a and
get into the alarm setting display.

0:09:15.700,0:09:18.670
That is what is
supposed to be shown here.

0:09:18.670,0:09:20.500
And of course we
can go back from that.

0:09:20.500,0:09:24.400
So if we are
in the alarm setting display

0:09:24.400,0:09:27.310
and we press a again, we
come back to the time setting.

0:09:27.310,0:09:28.840
And we want to
see the current time again.

0:09:32.620,0:09:34.030
The alarm can
be on or off.

0:09:34.030,0:09:35.260
That's already
shown here.

0:09:35.260,0:09:37.510
Of course, we only see
this when we are in the

0:09:37.510,0:09:40.990
alarm setting display and
not in the time display.

0:09:40.990,0:09:45.520
And then when we're
in this alarm setting display,

0:09:45.520,0:09:49.870
we can use the b button to switch
whether the alarm should be on or off.

0:09:51.220,0:09:53.852
We are in the alarm display
and the alarm is currently on.

0:09:53.852,0:09:57.790
And we press b, then
we're still in the alarm display.

0:09:57.790,0:09:59.080
But the
alarm is off.

0:09:59.080,0:10:02.320
And of course
it can be undone.

0:10:02.320,0:10:05.710
So we can also turn the alarm
back on if we just turned it off.

0:10:08.380,0:10:09.610
What is the
effect of this alarm?

0:10:09.610,0:10:11.740
It is to
make the clock beep.

0:10:11.740,0:10:15.730
It will beep whenever the
time changes to a full hour.

0:10:18.640,0:10:20.140
Of course, we don't see
the beeping sound here now.

0:10:20.140,0:10:22.480
This is just an information,
it will be simply shown in

0:10:22.480,0:10:25.300
the state diagram
in a suitable place:

0:10:25.300,0:10:28.180
Beep here
in this transition.

0:10:32.740,0:10:34.420
Is it complete
in the meantime?

0:10:34.420,0:10:34.960
No
it isn't.

0:10:34.960,0:10:40.810
Because in fact it's not meant to say
that when we're in the time display and

0:10:40.810,0:10:43.630
we switch to the alarm display,
that then the alarm is always on.

0:10:43.630,0:10:46.000
That would
be nonsense.

0:10:46.000,0:10:51.160
Let's imagine that we switch to the
alarm setting, then we turn the alarm off.

0:10:51.160,0:10:54.400
Then we also want to be
able to switch back to the time.

0:10:54.400,0:10:56.620
And not just after
we turn the alarm on.

0:10:57.280,0:10:58.900
So there would still have
to be a transition here.

0:10:58.900,0:11:04.790
Then here, even if we're in the alarm display
and alarm is off, we want to be able to

0:11:04.790,0:11:06.920
switch back to
the time display.

0:11:06.920,0:11:08.000
That means the
other way around:

0:11:08.000,0:11:12.980
If we wait a few minutes and then press
a again, we don't want to end up here.

0:11:13.490,0:11:15.530
After all, we intentionally
turned off the alarm.

0:11:15.530,0:11:19.640
We don't want to suddenly find out that
the alarm is on again just because we switched

0:11:19.640,0:11:22.190
to the time display and then wanted
to check whether it was on or off.

0:11:22.190,0:11:24.740
That's not how
it's supposed to be.

0:11:24.740,0:11:30.320
Instead, from the time
display, by pressing a,

0:11:30.320,0:11:32.960
we can end up
either here or here.

0:11:32.960,0:11:35.390
And that depends on
whether we turned the alarm

0:11:35.390,0:11:40.250
on or off the last time
we were in the alarm setting.

0:11:40.250,0:11:42.080
And then switched
to the time display.

0:11:42.710,0:11:44.900
That may
look non-deterministic here.

0:11:44.900,0:11:48.710
That here you don't know what's
going to happen when you press a.

0:11:48.710,0:11:50.150
But of course,
implicitly, one already knows.

0:11:50.150,0:11:54.380
Because the clock has a hidden state,
whether the alarm is on or off.

0:11:54.380,0:11:57.470
So the alarm has
several levels of states.

0:11:57.470,0:11:59.360
One, what is
the current time?

0:11:59.360,0:12:03.020
Is the alarm
currently on or off?

0:12:03.020,0:12:07.820
And am I currently showing the
time or the alarm state/alarm setting?

0:12:07.820,0:12:18.140
If you think about it now, if
you wanted to model some flat state diagram,

0:12:18.140,0:12:19.775
you would need quite
a lot of states.

0:12:19.775,0:12:24.920
One would have to remember, is one
in the alarm or in the time display?

0:12:24.920,0:12:26.750
Is the alarm
on or off?

0:12:26.750,0:12:27.830
What is
the current time?

0:12:27.830,0:12:33.380
Which consists of a number of
hours between 0 and 23, and

0:12:33.380,0:12:35.180
a number of minutes
between 0 and 60.

0:12:35.180,0:12:40.880
So somehow you would get 2
× 2 × 24 × 60 states.

0:12:40.880,0:12:43.070
That is
several thousand.

0:12:43.070,0:12:44.780
We do
not want that.

0:12:44.780,0:12:48.140
So we look for
a more compact representation.

0:12:48.140,0:12:59.150
And this will be realized in analogy to
the example of Harel via a UML state diagram.

0:12:59.150,0:13:01.940
In the
following videos.
